# 前言

> 原书: Preface

## 本章概述

本书（简称 CS:APP）是为计算机科学家、计算机工程师以及所有希望通过了解计算机系统"底层"运作原理来编写更好程序的人所写。

---

## 前言

本书（简称 CS:APP）是为计算机科学家、计算机工程师以及所有希望通过了解计算机系统"底层"运作原理来编写更好程序的人所写。

我们的目标是解释所有计算机系统背后持久不变的核心概念，并向你展示这些思想如何具体影响应用程序的正确性、性能和实用性。许多系统书籍是从构建者的角度编写的，描述如何实现硬件或系统软件，包括操作系统、编译器和网络接口。本书则从程序员的角度编写，描述应用程序员如何利用他们对系统的了解来编写更好的程序。当然，了解系统应该做什么是学习如何构建系统的良好第一步，因此本书也为那些继续深入实现系统硬件和软件的读者提供了宝贵的入门指导。大多数系统书籍也倾向于只关注系统的某一方面，例如硬件架构、操作系统、编译器或网络。本书涵盖所有这些方面，并以程序员的视角作为统一主题。

如果你学习并掌握本书中的概念，你将走上成为稀有的"强力程序员"之路——这种程序员知道事物如何运作，以及当它们出问题时如何修复。你将能够编写出更好地利用操作系统和系统软件所提供能力的程序，这些程序能在各种操作条件和运行时参数下正确运行，运行速度更快，并且能避免使程序容易受到网络攻击的缺陷。你将准备好深入研究更高级的主题，如编译器、计算机体系结构、操作系统、嵌入式系统、网络和网络安全。

## 关于读者背景的假设

本书聚焦于执行 x86-64 机器代码的系统。x86-64 是 Intel 及其竞争对手从 1978 年的 8086 微处理器开始沿循的演进路径中的最新版本。由于 Intel 为其微处理器系列使用的命名惯例，这类微处理器通常被俗称为"x86"。随着半导体技术的发展允许更多晶体管集成到单个芯片上，这些处理器在计算能力和内存容量方面都有了巨大进步。作为这一进程的一部分，它们从操作 16 位字，发展到引入 IA32 处理器后操作 32 位字，最近又发展到使用 x86-64 操作 64 位字。

我们研究这些机器如何在 Linux 上执行 C 程序。Linux 是众多起源于贝尔实验室最初开发的 Unix 操作系统的操作系统之一。这类操作系统的其他成员包括 Solaris、FreeBSD 和 macOS。近年来，通过 POSIX 和标准 Unix 规范标准化工作的努力，这些操作系统保持了高度的兼容性。因此，本书中的材料几乎可以直接应用于这些"类 Unix"操作系统。

> **C 语言新手？**
>
> **关于 C 编程语言的建议**
>
> 为了帮助那些 C 编程背景较弱（或完全没有）的读者，我们还特别添加了这些注释来强调 C 语言中特别重要的特性。我们假设你熟悉 C++ 或 Java。

本书包含大量在 Linux 系统上编译和运行的编程示例。我们假设你能访问这样的机器，并且能够登录并执行简单操作，如列出文件和更改目录。如果你的计算机运行 Microsoft Windows，我们建议你安装众多虚拟机环境之一（如 VirtualBox 或 VMware），这些环境允许为一个操作系统（客户操作系统）编写的程序在另一个操作系统（主机操作系统）下运行。

我们还假设你对 C 或 C++ 有一定了解。如果你之前只有 Java 经验，过渡将需要你付出更多努力，但我们会帮助你。Java 和 C 共享相似的语法和控制语句。然而，C 的某些方面（特别是指针、显式动态内存分配和格式化 I/O）在 Java 中不存在。幸运的是，C 是一门小型语言，并且在 Brian Kernighan 和 Dennis Ritchie 的经典著作"K&R"[61] 中有清晰而优美的描述。无论你的编程背景如何，请将 K&R 视为你个人系统库的必备部分。如果你之前的经验是使用解释型语言，如 Python、Ruby 或 Perl，在尝试使用本书之前，你肯定需要花一些时间学习 C。

本书前几章探讨了 C 程序与其机器语言对应物之间的交互。机器语言示例都是由运行在 x86-64 处理器上的 GNU gcc 编译器生成的。我们不假设你有任何硬件、机器语言或汇编语言编程的先前经验。

## 如何阅读本书

从程序员的角度学习计算机系统如何工作是非常有趣的，主要是因为你可以积极地去实践。每当你学到新东西，你都可以立即尝试并亲眼看到结果。事实上，我们相信学习系统的唯一方法就是实践系统，无论是解决具体问题还是在真实系统上编写和运行程序。

这一主题贯穿整本书。当引入一个新概念时，文中会紧跟一个或多个练习题，你应该立即完成这些练习来测试你的理解。练习题的答案在每章末尾。在阅读时，尝试自己解决每个问题，然后检查答案以确保你走在正确的轨道上。每章后面都有一组难度不等的家庭作业。你的教师在教师手册中有家庭作业的答案。对于每道家庭作业，我们显示了一个评级，表示我们认为它需要的努力程度：

- ◆ 只需几分钟。几乎不需要编程或完全不需要。
- ◆◆ 可能需要 20 分钟。通常涉及编写和测试一些代码。（其中许多源自我们在考试中给出的问题。）
- ◆◆◆ 需要大量努力，可能 1-2 小时。通常涉及编写和测试大量代码。
- ◆◆◆◆ 实验作业，需要长达 10 小时的努力。

```c
/* code/intro/hello.c */
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

**图 1** 一个典型的代码示例。

文中的每个代码示例都是直接从用 gcc 编译并在 Linux 系统上测试的 C 程序格式化而来，没有任何手动干预。当然，你的系统可能有不同版本的 gcc，或者完全不同的编译器，所以你的编译器可能生成不同的机器代码；但整体行为应该是相同的。所有源代码都可以从 CS:APP 网页（"CS:APP"是我们对本书标题的简称）获取，网址是 csapp.cs.cmu.edu。在文中，源程序的文件名记录在包围格式化代码的水平条中。例如，图 1 中的程序可以在 code/intro/ 目录下的 hello.c 文件中找到。我们鼓励你在遇到示例程序时在你的系统上尝试运行它们。

为了避免本书在篇幅和内容上过于庞大，我们创建了一些网络旁注，包含补充本书主要内容的材料。这些旁注在书中以 *chap:top* 的形式引用，其中 *chap* 是章节主题的简短编码，*top* 是所涵盖主题的简短代码。例如，网络旁注 *data:bool* 包含关于布尔代数的补充材料，用于第 2 章数据表示的讲解，而网络旁注 *arch:vlog* 包含使用 Verilog 硬件描述语言描述处理器设计的材料，补充第 4 章处理器设计的讲解。所有这些网络旁注都可以从 CS:APP 网页获取。

> **旁注**
>
> **什么是旁注？**
>
> 你会在整本书中遇到这种形式的旁注。旁注是括号内的评论，为你提供关于当前主题的额外见解。旁注有多种用途。有些是简短的历史课程。例如，C、Linux 和互联网从何而来？其他旁注旨在澄清学生经常感到困惑的概念。例如，高速缓存行、组和块之间有什么区别？其他旁注给出现实世界的例子，比如浮点错误如何导致法国火箭坠毁，或者商用磁盘驱动器的几何和操作参数。最后，有些旁注只是有趣的内容。例如，什么是"hoinky"？

## 本书概述

CS:APP 书籍由 12 章组成，旨在捕捉计算机系统的核心思想。以下是概述。

**第 1 章：计算机系统漫游。** 本章通过追踪一个简单的"hello, world"程序的生命周期，介绍计算机系统中的主要思想和主题。

**第 2 章：信息的表示和处理。** 我们涵盖计算机算术，强调影响程序员的无符号和二进制补码数表示的属性。我们考虑数字是如何表示的，因此对于给定的字长可以编码什么范围的值。我们考虑有符号和无符号数之间转换的影响。我们涵盖算术运算的数学属性。新手程序员常常惊讶地发现两个正数的（二进制补码）和或积可以是负数。另一方面，二进制补码算术满足整数算术的许多代数属性，因此编译器可以安全地将乘以常数转换为移位和加法序列。我们使用 C 的位级运算来演示布尔代数的原理和应用。我们根据 IEEE 浮点格式如何表示值以及浮点运算的数学属性来讲解它。

对计算机算术有扎实的理解对于编写可靠的程序至关重要。例如，程序员和编译器不能将表达式 `(x<y)` 替换为 `(x-y < 0)`，因为可能发生溢出。他们甚至不能将其替换为表达式 `(-y < -x)`，因为二进制补码表示中负数和正数的范围不对称。算术溢出是编程错误和安全漏洞的常见来源，然而很少有其他书籍从程序员的角度涵盖计算机算术的属性。

**第 3 章：程序的机器级表示。** 我们教你如何阅读 C 编译器生成的 x86-64 机器代码。我们涵盖为不同控制结构（如条件语句、循环和 switch 语句）生成的基本指令模式。我们涵盖过程的实现，包括栈分配、寄存器使用约定和参数传递。我们涵盖不同数据结构（如结构体、联合体和数组）的分配和访问方式。我们涵盖实现整数和浮点算术的指令。我们还使用程序的机器级视图作为理解常见代码安全漏洞（如缓冲区溢出）的方法，以及程序员、编译器和操作系统可以采取的减少这些威胁的步骤。学习本章的概念有助于你成为更好的程序员，因为你将理解程序是如何在机器上表示的。一个确定的好处是你将对指针有透彻而具体的理解。

**第 4 章：处理器体系结构。** 本章涵盖基本的组合和时序逻辑元素，然后展示如何将这些元素组合成一个执行简化的 x86-64 指令集子集（称为"Y86-64"）的数据通路。我们从单周期数据通路的设计开始。这种设计概念上非常简单，但不会很快。然后我们引入流水线，其中处理一条指令所需的不同步骤被实现为独立的阶段。在任何给定时间，每个阶段可以处理不同的指令。我们的五阶段处理器流水线更加现实。处理器设计的控制逻辑使用一种简单的硬件描述语言 HCL 来描述。用 HCL 编写的硬件设计可以编译并链接到教科书提供的模拟器中，它们还可以用于生成适合综合成工作硬件的 Verilog 描述。

**第 5 章：优化程序性能。** 本章介绍了许多改进代码性能的技术，其思想是程序员学会以某种方式编写 C 代码，使编译器能够生成高效的机器代码。我们从减少程序工作量的转换开始，这应该是为任何机器编写任何程序时的标准做法。然后我们进展到增强生成的机器代码中指令级并行度的转换，从而提高它们在现代"超标量"处理器上的性能。为了激发这些转换，我们引入了现代乱序处理器工作原理的简单操作模型，并展示如何根据程序图形表示中的关键路径来衡量程序的潜在性能。你会惊讶于通过简单的 C 代码转换可以多大程度地加速程序。

**第 6 章：存储器层次结构。** 内存系统是计算机系统中对应用程序员最可见的部分之一。到目前为止，你一直依赖于内存系统作为具有统一访问时间的线性数组的概念模型。实际上，内存系统是具有不同容量、成本和访问时间的存储设备层次结构。我们涵盖不同类型的 RAM 和 ROM 存储器以及磁盘和固态硬盘的几何结构和组织。我们描述这些存储设备如何排列成层次结构。我们展示这种层次结构如何通过引用局部性成为可能。我们通过将内存系统视为一座"内存山"来使这些概念具体化，这座山有时间局部性的山脊和空间局部性的斜坡。最后，我们向你展示如何通过改善程序的时间和空间局部性来提高应用程序的性能。

**第 7 章：链接。** 本章涵盖静态和动态链接，包括可重定位和可执行目标文件、符号解析、重定位、静态库、共享目标库、位置无关代码和库打桩的概念。大多数系统文本不涵盖链接，但我们出于两个原因涵盖它。首先，程序员可能遇到的一些最令人困惑的错误与链接过程中的故障有关，特别是对于大型软件包。其次，链接器生成的目标文件与加载、虚拟内存和内存映射等概念相关。

**第 8 章：异常控制流。** 在这部分内容中，我们超越单程序模型，引入异常控制流的一般概念（即正常分支和过程调用之外的控制流变化）。我们涵盖存在于系统所有级别的异常控制流示例，从低级硬件异常和中断，到并发进程之间的上下文切换，到由接收 Linux 信号引起的控制流突变，再到 C 中打破栈纪律的非本地跳转。

这是本书中我们介绍进程这一基本概念的部分——进程是正在执行的程序的抽象。你将学习进程如何工作，以及如何从应用程序中创建和操作它们。我们展示应用程序员如何通过 Linux 系统调用利用多个进程。当你完成本章时，你将能够编写一个带有作业控制的简单 Linux shell。这也是你第一次接触并发程序执行所产生的非确定性行为。

**第 9 章：虚拟内存。** 我们对虚拟内存系统的讲解旨在让读者理解它的工作原理和特性。我们希望你知道不同的同时运行的进程如何各自使用相同范围的地址，共享某些页面但拥有其他页面的独立副本。我们还涵盖管理和操作虚拟内存的相关问题。特别是，我们涵盖存储分配器的操作，如标准库的 malloc 和 free 操作。涵盖这些材料有多种目的。它强化了虚拟内存空间只是程序可以划分为不同存储单元的字节数组这一概念。它帮助你理解包含内存引用错误（如存储泄漏和无效指针引用）的程序的影响。最后，许多应用程序员编写自己的存储分配器，针对应用程序的需求和特性进行优化。本章比其他任何章节都更能展示以统一方式涵盖计算机系统硬件和软件两方面的好处。传统的计算机体系结构和操作系统文本只讲述虚拟内存故事的一部分。

**第 10 章：系统级 I/O。** 我们涵盖 Unix I/O 的基本概念，如文件和描述符。我们描述文件如何共享，I/O 重定向如何工作，以及如何访问文件元数据。我们还开发了一个健壮的缓冲 I/O 包，正确处理一种称为短计数的奇怪行为，即库函数只读取部分输入数据。我们涵盖 C 标准 I/O 库及其与 Linux I/O 的关系，重点关注标准 I/O 的局限性，这些局限性使其不适合网络编程。总的来说，本章涵盖的主题是接下来两章关于网络和并发编程的构建模块。

**第 11 章：网络编程。** 网络是有趣的 I/O 设备来编程，它将我们在本书前面学习的许多概念联系在一起，如进程、信号、字节序、内存映射和动态存储分配。网络程序还为并发提供了一个引人注目的背景，这是下一章的主题。本章是网络编程的一个薄片，让你能够编写一个简单的 Web 服务器。我们涵盖所有网络应用程序基础的客户端-服务器模型。我们展示程序员对互联网的视角，并展示如何使用套接字接口编写互联网客户端和服务器。最后，我们介绍 HTTP 并开发一个简单的迭代式 Web 服务器。

**第 12 章：并发编程。** 本章使用互联网服务器设计作为贯穿始终的激励示例来介绍并发编程。我们比较和对比编写并发程序的三种基本机制——进程、I/O 多路复用和线程——并展示如何使用它们构建并发互联网服务器。我们涵盖使用 P 和 V 信号量操作进行同步的基本原理、线程安全和可重入性、竞争条件和死锁。编写并发代码对大多数服务器应用程序来说是必不可少的。我们还描述使用线程级编程在应用程序中表达并行性，从而在多核处理器上实现更快的执行。让所有核心都参与解决单个计算问题需要仔细协调并发线程，既要保证正确性，又要实现高性能。

## 第三版的新内容

本书第一版出版时版权为 2003 年，第二版版权为 2011 年。考虑到计算机技术的快速发展，本书内容保持得相当好。在 Linux（及相关操作系统）上运行 C 程序的 Intel x86 机器已被证明是一种组合，至今仍涵盖许多系统。然而，硬件技术、编译器、程序库接口的变化，以及许多教授这些材料的讲师的经验，促使了一次重大修订。

与第二版相比，最大的整体变化是我们将讲解从基于 IA32 和 x86-64 的混合切换到完全基于 x86-64。这种焦点转移影响了许多章节的内容。以下是重大变化的摘要。

**第 1 章：计算机系统漫游。** 我们将阿姆达尔定律的讨论从第 5 章移到了本章。

**第 2 章：信息的表示和处理。** 读者和评审者一致反馈本章的一些材料可能有点令人难以消化。因此，我们试图通过澄清我们深入更数学化呈现方式的要点来使材料更易于理解。这使读者能够首先略过数学细节以获得高层概述，然后再返回进行更深入的阅读。

**第 3 章：程序的机器级表示。** 我们从早期基于 IA32 和 x86-64 混合的讲解转换为完全基于 x86-64。我们还针对更新版本的 gcc 生成的代码风格进行了更新。结果是大量重写，包括改变了一些概念呈现的顺序。我们还首次包含了对操作浮点数据的程序的机器级支持的讲解。我们创建了一个描述 IA32 机器代码的网络旁注，以供遗留参考。

**第 4 章：处理器体系结构。** 我们将早期基于 32 位架构的处理器设计修订为支持 64 位字和操作的设计。

**第 5 章：优化程序性能。** 我们更新了材料以反映近几代 x86-64 处理器的性能能力。随着更多功能单元和更复杂控制逻辑的引入，我们基于程序数据流表示开发的程序性能模型已成为比以前更可靠的性能预测器。

**第 6 章：存储器层次结构。** 我们更新了材料以反映更新的技术。

**第 7 章：链接。** 我们为 x86-64 重写了本章，扩展了关于使用 GOT 和 PLT 创建位置无关代码的讨论，并添加了关于一种称为库打桩的强大链接技术的新章节。

**第 8 章：异常控制流。** 我们添加了对信号处理程序更严格的处理，包括异步信号安全函数、编写信号处理程序的具体指南，以及使用 sigsuspend 等待处理程序。

**第 9 章：虚拟内存。** 本章只有轻微变化。

**第 10 章：系统级 I/O。** 我们添加了关于文件和文件层次结构的新章节，但除此之外，本章只有轻微变化。

**第 11 章：网络编程。** 我们引入了使用现代 getaddrinfo 和 getnameinfo 函数进行协议无关和线程安全网络编程的技术，这些函数取代了过时且不可重入的 gethostbyname 和 gethostbyaddr 函数。

**第 12 章：并发编程。** 我们增加了使用线程级并行性使程序在多核机器上运行更快的内容覆盖。

此外，我们在整本书中添加和修订了许多练习题和家庭作业。

## 本书的起源

本书源于我们 1998 年秋季在卡内基梅隆大学开发的一门入门课程，名为 15-213：计算机系统导论（ICS）[14]。ICS 课程从那时起每学期都在开设。每学期有超过 400 名学生选修这门课程。学生从大二到各种专业的研究生都有。它是卡内基梅隆大学计算机科学和电子与计算机工程系所有本科生的必修核心课程，并且已成为计算机科学和电子与计算机工程系大多数高级系统课程的先修课程。

ICS 的理念是以不同的方式向学生介绍计算机。我们的学生中很少有人会有机会构建一个计算机系统。另一方面，大多数学生，包括所有计算机科学家和计算机工程师，都需要每天使用和编程计算机。因此，我们决定从程序员的角度教授系统，使用以下过滤器：我们只会涵盖影响用户级 C 程序性能、正确性或实用性的主题。

例如，硬件加法器和总线设计等主题被排除在外。机器语言等主题被包括在内；但我们不是关注如何手写汇编语言，而是关注 C 编译器如何将 C 结构转换为机器代码，包括指针、循环、过程调用和 switch 语句。此外，我们将对系统采取更广泛、更整体的视角，将其视为硬件和系统软件的统一体，涵盖链接、加载、进程、信号、性能优化、虚拟内存、I/O 以及网络和并发编程等主题。

这种方法使我们能够以实用、具体、动手操作且令学生兴奋的方式教授 ICS 课程。我们的学生和教师同事的反应是即时且压倒性的积极，我们意识到 CMU 以外的其他人可能会从使用我们的方法中受益。因此有了这本书，它是从 ICS 讲义发展而来的，我们现在已经修订它以反映技术的变化和计算机系统实现方式的变化。

通过本书的多个版本和多种翻译，ICS 及其许多变体已成为全球数百所学院和大学计算机科学和计算机工程课程的一部分。

## 给教师：基于本书的课程

教师可以使用 CS:APP 书籍教授许多不同类型的系统课程。这些课程的五个类别如图 2 所示。具体课程取决于课程要求、个人偏好以及学生的背景和能力。在图中从左到右，课程的特点是越来越强调系统的程序员视角。以下是简要描述。

**ORG。** 一门以非传统风格涵盖传统主题的计算机组成原理课程。涵盖逻辑设计、处理器架构、汇编语言和内存系统等传统主题。然而，更强调对程序员的影响。例如，数据表示与 C 程序的数据类型和操作相关联，汇编代码的讲解基于 C 编译器生成的机器代码而不是手写的汇编代码。

**ORG+。** ORG 课程加上额外强调硬件对应用程序性能的影响。与 ORG 相比，学生学习更多关于代码优化和改进其 C 程序内存性能的内容。

**ICS。** 基线 ICS 课程，旨在培养理解硬件、操作系统和编译系统对其应用程序性能和正确性影响的开明程序员。与 ORG+ 的一个重大区别是不涵盖低级处理器架构。相反，程序员使用现代乱序处理器的更高级模型工作。ICS 课程非常适合 10 周的学季，如果以更悠闲的节奏进行，也可以延长到 15 周的学期。

**ICS+。** 基线 ICS 课程加上系统编程主题的额外覆盖，如系统级 I/O、网络编程和并发编程。这是卡内基梅隆大学的一学期课程，涵盖 CS:APP 中除低级处理器架构以外的每一章。

| 课程 | 章节 | 主题 | ORG | ORG+ | ICS | ICS+ | SP |
|------|------|------|-----|------|-----|------|----|
| 1 | 系统漫游 | • | • | • | • | • |
| 2 | 数据表示 | • | • | • | • | ⊙(d) |
| 3 | 机器语言 | • | • | • | • | • |
| 4 | 处理器架构 | • | • | | | |
| 5 | 代码优化 | | • | • | • | |
| 6 | 存储器层次结构 | ⊙(a) | • | • | • | ⊙(a) |
| 7 | 链接 | | | ⊙(c) | ⊙(c) | • |
| 8 | 异常控制流 | | | • | • | • |
| 9 | 虚拟内存 | ⊙(b) | • | • | • | • |
| 10 | 系统级 I/O | | | | • | • |
| 11 | 网络编程 | | | | • | • |
| 12 | 并发编程 | | | | • | • |

**图 2** 基于 CS:APP 书籍的五门系统课程。ICS+ 是卡内基梅隆大学的 15-213 课程。注：⊙ 符号表示部分涵盖一章，具体如下：(a) 仅硬件；(b) 无动态存储分配；(c) 无动态链接；(d) 无浮点。

**SP。** 系统编程课程。该课程类似于 ICS+，但去掉了浮点和性能优化，更加强调系统编程，包括进程控制、动态链接、系统级 I/O、网络编程和并发编程。教师可能希望从其他来源补充高级主题，如守护进程、终端控制和 Unix IPC。

图 2 的主要信息是 CS:APP 书籍为学生和教师提供了许多选择。如果你希望学生接触低级处理器架构，那么可以通过 ORG 和 ORG+ 课程实现这一选择。另一方面，如果你想从当前的计算机组成原理课程切换到 ICS 或 ICS+ 课程，但对一次性做出如此剧烈的改变持谨慎态度，那么你可以逐步向 ICS 过渡。你可以从 ORG 开始，它以非传统方式教授传统主题。一旦你熟悉了这些材料，你就可以转向 ORG+，最终到 ICS。如果学生没有 C 语言经验（例如，他们只用 Java 编过程），你可以花几周时间学习 C，然后涵盖 ORG 或 ICS 的材料。

最后，我们注意到 ORG+ 和 SP 课程可以构成一个很好的两学期序列（无论是学季还是学期）。或者你可以考虑将 ICS+ 作为一学期的 ICS 和一学期的 SP 来提供。

## 给教师：经过课堂检验的实验练习

卡内基梅隆大学的 ICS+ 课程获得了学生极高的评价。学生课程评估的中位数为 5.0/5.0，平均值为 4.6/5.0 是典型的。学生将有趣、令人兴奋且相关的实验练习列为主要原因。实验可从 CS:APP 网页获取。以下是本书提供的实验示例。

**数据实验（Data Lab）。** 该实验要求学生实现简单的逻辑和算术函数，但使用高度受限的 C 子集。例如，他们必须仅使用位级操作计算数字的绝对值。该实验帮助学生理解 C 数据类型的位级表示和数据操作的位级行为。

**二进制炸弹实验（Binary Bomb Lab）。** 二进制炸弹是作为目标代码文件提供给学生的程序。运行时，它提示用户输入六个不同的字符串。如果其中任何一个不正确，炸弹就会"爆炸"，打印错误消息并在评分服务器上记录该事件。学生必须通过反汇编和逆向工程程序来"拆除"他们独特的炸弹，以确定六个字符串应该是什么。该实验教学生理解汇编语言，也迫使他们学习如何使用调试器。

**缓冲区溢出实验（Buffer Overflow Lab）。** 学生需要通过利用缓冲区溢出漏洞来修改二进制可执行文件的运行时行为。该实验向学生讲授栈规则以及编写易受缓冲区溢出攻击的代码的危险。

**架构实验（Architecture Lab）。** 第 4 章的几个家庭作业可以组合成一个实验作业，学生修改处理器的 HCL 描述以添加新指令、更改分支预测策略，或添加或删除旁路路径和寄存器端口。生成的处理器可以被模拟并通过自动化测试运行，这些测试将检测大多数可能的错误。该实验让学生体验处理器设计中令人兴奋的部分，而不需要完整的逻辑设计和硬件描述语言背景。

**性能实验（Performance Lab）。** 学生必须优化应用程序内核函数的性能，如卷积或矩阵转置。该实验非常清楚地展示了高速缓存存储器的特性，并让学生获得低级程序优化的经验。

**缓存实验（Cache Lab）。** 在这个性能实验的替代方案中，学生编写一个通用缓存模拟器，然后优化一个小的矩阵转置内核以最小化模拟缓存上的缺失次数。我们使用 Valgrind 工具为矩阵转置内核生成真实的地址跟踪。

**Shell 实验（Shell Lab）。** 学生实现自己的 Unix shell 程序，带有作业控制，包括 Ctrl+C 和 Ctrl+Z 按键以及 fg、bg 和 jobs 命令。这是学生第一次接触并发，它让他们清楚地了解 Unix 进程控制、信号和信号处理。

**Malloc 实验（Malloc Lab）。** 学生实现自己版本的 malloc、free 和（可选的）realloc。该实验让学生清楚地理解数据布局和组织，并要求他们评估空间和时间效率之间的不同权衡。

**代理实验（Proxy Lab）。** 学生实现一个位于其浏览器和万维网其余部分之间的并发 Web 代理。该实验让学生接触 Web 客户端和服务器等主题，并将课程中的许多概念联系在一起，如字节序、文件 I/O、进程控制、信号、信号处理、内存映射、套接字和并发。学生喜欢能够看到他们的程序与真实的 Web 浏览器和 Web 服务器一起运行。

CS:APP 教师手册详细讨论了这些实验，以及下载支持软件的说明。

## 第三版致谢

很高兴在此致谢并感谢帮助我们制作这第三版 CS:APP 文本的人们。

我们要感谢多年来教授 ICS 课程的卡内基梅隆大学同事，他们提供了如此富有洞察力的反馈和鼓励：Guy Blelloch、Roger Dannenberg、David Eckhardt、Franz Franchetti、Greg Ganger、Seth Goldstein、Khaled Harras、Greg Kesden、Bruce Maggs、Todd Mowry、Andreas Nowatzyk、Frank Pfenning、Markus Pueschel 和 Anthony Rowe。David Winters 在安装和配置参考 Linux 机器方面非常有帮助。

Jason Fritts（圣路易斯大学）和 Cindy Norris（阿巴拉契亚州立大学）为我们提供了对第二版详细而深思熟虑的评审。龚益力（武汉大学）撰写了中文翻译，维护了中文版的勘误页，并贡献了许多错误报告。Godmar Back（弗吉尼亚理工大学）通过向我们介绍异步信号安全和协议无关网络编程的概念，帮助我们显著改进了文本。

非常感谢在第二版中报告错误的敏锐读者：Rami Ammari、Paul Anagnostopoulos、Lucas Bärenfänger、Godmar Back、Ji Bin、Sharbel Bousemaan、Richard Callahan、Seth Chaiken、Cheng Chen、Libo Chen、Tao Du、Pascal Garcia、Yili Gong、Ronald Greenberg、Dorukhan Gülöz、Dong Han、Dominik Helm、Ronald Jones、Mustafa Kazdagli、Gordon Kindlmann、Sankar Krishnan、Kanak Kshetri、Junlin Lu、Qiangqiang Luo、Sebastian Luy、Lei Ma、Ashwin Nanjappa、Gregoire Paradis、Jonas Pfenninger、Karl Pichotta、David Ramsey、Kaustabh Roy、David Selvaraj、Sankar Shanmugam、Dominique Smulkowska、Dag Sørbø、Michael Spear、Yu Tanaka、Steven Tricanowicz、Scott Wright、Waiki Wright、Han Xu、Zhengshan Yan、Firo Yang、Shuang Yang、John Ye、Taketo Yoshida、Yan Zhu 和 Michael Zink。

还要感谢为实验做出贡献的读者，包括 Godmar Back（弗吉尼亚理工大学）、Taymon Beal（伍斯特理工学院）、Aran Clauson（西华盛顿大学）、Cary Gray（惠顿学院）、Paul Haiduk（西德克萨斯农工大学）、Len Hamey（麦考瑞大学）、Eddie Kohler（哈佛大学）、Hugh Lauer（伍斯特理工学院）、Robert Marmorstein（朗伍德大学）和 James Riely（德保罗大学）。

再次感谢 Windfall Software 的 Paul Anagnostopoulos 出色地完成了本书的排版工作并领导了制作过程。非常感谢 Paul 和他的出色团队：Richard Camp（文字编辑）、Jennifer McClain（校对）、Laurel Muller（美术制作）和 Ted Laux（索引）。Paul 甚至发现了我们对 BSS 首字母缩写词起源描述中的一个错误，该错误自第一版以来一直未被发现！

最后，我们要感谢 Prentice Hall 的朋友们。Marcia Horton 和我们的编辑 Matt Goldstein 一直不遗余力地支持和鼓励我们，我们对他们深表感激。

## 第二版致谢

我们深深感谢帮助我们制作这第二版 CS:APP 文本的众多人士。

首先，我们要感谢在卡内基梅隆大学教授 ICS 课程的同事们，感谢他们富有洞察力的反馈和鼓励：Guy Blelloch、Roger Dannenberg、David Eckhardt、Greg Ganger、Seth Goldstein、Greg Kesden、Bruce Maggs、Todd Mowry、Andreas Nowatzyk、Frank Pfenning 和 Markus Pueschel。

还要感谢为第一版勘误页做出贡献的敏锐读者：Daniel Amelang、Rui Baptista、Quarup Barreirinhas、Michael Bombyk、Jörg Brauer、Jordan Brough、Yixin Cao、James Caroll、Rui Carvalho、Hyoung-Kee Choi、Al Davis、Grant Davis、Christian Dufour、Mao Fan、Tim Freeman、Inge Frick、Max Gebhardt、Jeff Goldblat、Thomas Gross、Anita Gupta、John Hampton、Hiep Hong、Greg Israelsen、Ronald Jones、Haudy Kazemi、Brian Kell、Constantine Kousoulis、Sacha Krakowiak、Arun Krishnaswamy、Martin Kulas、Michael Li、Zeyang Li、Ricky Liu、Mario Lo Conte、Dirk Maas、Devon Macey、Carl Marcinik、Will Marrero、Simone Martins、Tao Men、Mark Morrissey、Venkata Naidu、Bhas Nalabothula、Thomas Niemann、Eric Peskin、David Po、Anne Rogers、John Ross、Michael Scott、Seiki、Ray Shih、Darren Shultz、Erik Silkensen、Suryanto、Emil Tarazi、Nawanan Theera-Ampornpunt、Joe Trdinich、Michael Trigoboff、James Troup、Martin Vopatek、Alan West、Betsy Wolff、Tim Wong、James Woodruff、Scott Wright、Jackie Xiao、Guanpeng Xu、Qing Xu、Caren Yang、Yin Yongsheng、Wang Yuanxuan、Steven Zhang 和 Day Zhong。特别感谢 Inge Frick，他在我们的锁和复制示例中发现了一个微妙的深拷贝错误，以及 Ricky Liu 令人惊叹的校对技能。

我们的 Intel Labs 同事 Andrew Chien 和 Limor Fix 在整个文本编写过程中给予了非常大的支持。Steve Schlosser 慷慨地提供了一些磁盘驱动器特性数据。Casey Helfrich 和 Michael Ryan 安装并维护了我们的新 Core i7 机器。Michael Kozuch、Babu Pillai 和 Jason Campbell 就内存系统性能、多核系统和功率墙提供了宝贵的见解。Phil Gibbons 和 Shimin Chen 分享了他们在固态硬盘设计方面的丰富专业知识。

我们能够借助许多人的才能，包括 Wen-Mei Hwu、Markus Pueschel 和 Jiri Simsa，提供详细评论和高层建议。James Hoe 帮助我们创建了 Y86 处理器的 Verilog 版本，并完成了综合成工作硬件所需的所有工作。

非常感谢为手稿草案提供评审的同事：James Archibald（杨百翰大学）、Richard Carver（乔治梅森大学）、Mirela Damian（维拉诺瓦大学）、Peter Dinda（西北大学）、John Fiore（天普大学）、Jason Fritts（圣路易斯大学）、John Greiner（莱斯大学）、Brian Harvey（加州大学伯克利分校）、Don Heller（宾州州立大学）、Wei Chung Hsu（明尼苏达大学）、Michelle Hugue（马里兰大学）、Jeremy Johnson（德雷塞尔大学）、Geoff Kuenning（哈维穆德学院）、Ricky Liu、Sam Madden（麻省理工学院）、Fred Martin（马萨诸塞大学洛厄尔分校）、Abraham Matta（波士顿大学）、Markus Pueschel（卡内基梅隆大学）、Norman Ramsey（塔夫茨大学）、Glenn Reinmann（加州大学洛杉矶分校）、Michela Taufer（特拉华大学）和 Craig Zilles（伊利诺伊大学厄巴纳-香槟分校）。

Windfall Software 的 Paul Anagnostopoulos 出色地完成了本书的排版工作并领导了制作团队。非常感谢 Paul 和他的优秀团队：Rick Camp（文字编辑）、Joe Snowden（排版）、MaryEllen N. Oliver（校对）、Laurel Muller（美术设计）和 Ted Laux（索引）。

最后，我们要感谢 Prentice Hall 的朋友们。Marcia Horton 一直在我们身边。我们的编辑 Matt Goldstein 从始至终提供了出色的领导。我们对他们的帮助、鼓励和洞察力深表感激。

## 第一版致谢

我们深深感谢许多朋友和同事的深思熟虑的批评和鼓励。特别感谢我们的 15-213 学生，他们的热情和活力激励着我们前进。Nick Carter 和 Vinny Furia 慷慨地提供了他们的 malloc 包。

Guy Blelloch、Greg Kesden、Bruce Maggs 和 Todd Mowry 在多个学期教授了这门课程，给予我们鼓励，并帮助改进课程材料。Herb Derby 提供了早期的精神指导和鼓励。Allan Fisher、Garth Gibson、Thomas Gross、Satya、Peter Steenkiste 和 Hui Zhang 从一开始就鼓励我们开发这门课程。Garth 早期的一个建议让整个项目开始运转，这被 Allan Fisher 领导的一个小组接手并完善。Mark Stehlik 和 Peter Lee 非常支持将这些材料纳入本科课程。Greg Kesden 就 ICS 对操作系统课程的影响提供了有益的反馈。Greg Ganger 和 Jiri Schindler 慷慨地提供了一些磁盘驱动器特性数据并回答了我们关于现代磁盘的问题。Tom Stricker 向我们展示了内存山。James Hoe 就如何呈现处理器架构提供了有用的想法和反馈。

一群特别的学生——Khalil Amiri、Angela Demke Brown、Chris Colohan、Jason Crawford、Peter Dinda、Julio Lopez、Bruce Lowekamp、Jeff Pierce、Sanjay Rao、Balaji Sarpeshkar、Blake Scholl、Sanjit Seshia、Greg Steffan、Tiankai Tu、Kip Walker 和 Yinglian Xie——在帮助我们开发课程内容方面发挥了重要作用。特别是，Chris Colohan 建立了一种延续至今的有趣（和搞笑）的基调，并发明了传奇的"二进制炸弹"，这已被证明是教授机器代码和调试概念的绝佳工具。

Chris Bauer、Alan Cox、Peter Dinda、Sandhya Dwarkadas、John Greiner、Don Heller、Bruce Jacob、Barry Johnson、Bruce Lowekamp、Greg Morrisett、Brian Noble、Bobbie Othmer、Bill Pugh、Michael Scott、Mark Smotherman、Greg Steffan 和 Bob Wier 花费了他们没有的时间来阅读并为本书的早期草稿提出建议。非常特别感谢 Al Davis（犹他大学）、Peter Dinda（西北大学）、John Greiner（莱斯大学）、Wei Hsu（明尼苏达大学）、Bruce Lowekamp（威廉与玛丽学院）、Bobbie Othmer（明尼苏达大学）、Michael Scott（罗彻斯特大学）和 Bob Wier（落基山学院）对测试版进行的课堂测试。也特别感谢他们的学生！

我们还要感谢 Prentice Hall 的同事们。Marcia Horton、Eric Frank 和 Harold Stone 一直坚定不移地支持我们的愿景。Harold 还帮助我们准确呈现 RISC 和 CISC 处理器架构的历史视角。Jerry Ralya 提供了敏锐的见解，教会了我们很多关于优秀写作的知识。

最后，我们要感谢伟大的技术作家 Brian Kernighan 和已故的 W. Richard Stevens，是他们向我们展示了技术书籍也可以很美。

谢谢大家。

Randy Bryant
Dave O'Hallaron
匹兹堡，宾夕法尼亚州

Pearson 要感谢并致谢 MS Ramaiah Institute of Technology 的 Chetan Venkatesh、Don Bosco College 的 Desny Antony 和 SP College 的 Chitra Dhawale 对全球版的评审。

---

## 本章小结

本前言介绍了《深入理解计算机系统》(CS:APP) 的核心理念和使用方法：

- **定位与目标**：本书从程序员角度讲解计算机系统，帮助读者理解底层原理以编写更好的程序
- **读者背景**：假设读者熟悉 C/C++ 编程，本书聚焦于 x86-64 架构和 Linux 系统
- **学习方法**：强调"做中学"——通过练习题、家庭作业和实验来掌握概念
- **内容结构**：12 章内容涵盖数据表示、机器代码、处理器架构、内存层次、链接、异常控制流、虚拟内存、I/O、网络编程和并发编程
- **课程灵活性**：可根据教学需求组织为 ORG、ORG+、ICS、ICS+ 或 SP 等不同类型的课程
- **配套实验**：提供 Data Lab、Binary Bomb Lab、Buffer Overflow Lab 等经典实验

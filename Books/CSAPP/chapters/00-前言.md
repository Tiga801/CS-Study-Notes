# 前言

> 原书: Preface

## 本章概述

本书（简称 CS:APP）是为计算机科学家、计算机工程师以及所有希望通过了解计算机系统"底层"运作原理来编写更好程序的人所写。

---

## 前言

本书（简称 CS:APP）是为计算机科学家、计算机工程师以及所有希望通过了解计算机系统"底层"运作原理来编写更好程序的人所写。

我们的目标是解释所有计算机系统背后持久不变的核心概念，并向你展示这些思想如何具体影响应用程序的正确性、性能和实用性。许多系统书籍是从构建者的角度编写的，描述如何实现硬件或系统软件，包括操作系统、编译器和网络接口。本书则从程序员的角度编写，描述应用程序员如何利用他们对系统的了解来编写更好的程序。当然，了解系统应该做什么是学习如何构建系统的良好第一步，因此本书也为那些继续深入实现系统硬件和软件的读者提供了宝贵的入门指导。大多数系统书籍也倾向于只关注系统的某一方面，例如硬件架构、操作系统、编译器或网络。本书涵盖所有这些方面，并以程序员的视角作为统一主题。

如果你学习并掌握本书中的概念，你将走上成为稀有的"强力程序员"之路——这种程序员知道事物如何运作，以及当它们出问题时如何修复。你将能够编写出更好地利用操作系统和系统软件所提供能力的程序，这些程序能在各种操作条件和运行时参数下正确运行，运行速度更快，并且能避免使程序容易受到网络攻击的缺陷。你将准备好深入研究更高级的主题，如编译器、计算机体系结构、操作系统、嵌入式系统、网络和网络安全。

## 关于读者背景的假设

本书聚焦于执行 x86-64 机器代码的系统。x86-64 是 Intel 及其竞争对手自 1978 年推出 8086 微处理器以来，沿着既有架构演进路线发展而来的最新版本。由于 Intel 对其微处理器系列所采用的命名惯例，这类微处理器通常被统称为 “x86”。随着半导体技术的不断发展，单个芯片上可集成的晶体管数量持续增加，使得处理器在计算能力和内存寻址能力方面均取得了显著提升。作为这一演进过程的一部分，处理器体系结构经历了从最初支持 16 位字长，到引入 IA-32 架构以支持 32 位字长，再到近年来发展为采用 x86-64 架构以支持 64 位字长的转变。

我们将研究这些机器如何在 Linux 平台上执行 C 程序。Linux 是一类起源于贝尔实验室早期开发的 Unix 操作系统家族中的成员。该家族的其他代表还包括 Solaris、FreeBSD 以及 macOS。近年来，得益于 POSIX 标准和 Unix 规范的持续标准化，这些操作系统在接口和行为上保持了高度的兼容性。因此，本书中的大部分内容几乎可以不加修改地应用于这些“类 Unix”操作系统。

> **C 语言新手？**
>
> **关于 C 编程语言的建议**
>
> 为了帮助那些 C 编程背景较弱（或完全没有）的读者，我们还特别添加了这些注释来强调 C 语言中特别重要的特性。我们假设你熟悉 C++ 或 Java。

本书包含大量需要在 Linux 系统上编译和运行的编程示例。我们假设读者能够访问一台 Linux 机器，并具备基本的操作能力，例如列出文件、切换目录等。如果你的计算机运行的是 Microsoft Windows，建议安装一种虚拟机环境（如 VirtualBox 或 VMware），以便在主机操作系统上运行用于其他操作系统的程序，从而搭建相应的 Linux 运行环境。

我们同样假设你对 C 或 C++ 具有一定的基础了解。如果你此前仅有 Java 编程经验，过渡到 C 语言可能需要投入更多精力，但我们会在学习过程中提供必要的帮助。Java 与 C 在语法结构和控制语句方面具有较多相似之处，但 C 语言的一些关键特性——尤其是指针、显式的动态内存分配以及格式化 I/O——在 Java 中并不存在。幸运的是，C 是一门相对精炼的语言，其核心内容在 Brian Kernighan 和 Dennis Ritchie 的经典著作《The C Programming Language》（通常简称为 “K&R”）中得到了清晰而优雅的阐述。无论你的编程背景如何，都应将 K&R 视为个人系统编程知识库中不可或缺的一部分。如果你此前主要使用的是 Python、Ruby 或 Perl 等解释型语言，那么在正式阅读本书之前，势必需要先花时间系统地学习 C 语言。

本书前几章重点探讨了 C 程序与其对应的机器语言之间的关系。书中所示的机器语言示例均由运行在 x86-64 处理器上的 GNU gcc 编译器生成。我们不假设读者具备任何硬件、机器语言或汇编语言编程方面的先验知识。

## 如何阅读本书

从程序员的角度学习计算机系统的工作原理是一件非常有趣的事情，原因在于你可以亲身参与并不断实践。每当你学到一个新概念，都可以立刻动手尝试，并直接观察其运行结果。事实上，我们认为，学习计算机系统的唯一途径就是实践——无论是通过解决具体问题，还是在真实系统上编写并运行程序。

这一理念贯穿全书。每当引入一个新概念，正文后都会紧接着安排一个或多个练习题，鼓励你立即动手，以检验自己对内容的理解。练习题的参考答案位于每章末尾。阅读过程中，建议你先独立完成每一道题目，再对照答案检查自己的理解是否正确。此外，每章结尾还配有一组难度不等的课后作业，其答案收录在教师手册中。对于每一道作业题，我们都给出了一个难度评级，用以表示我们认为完成该题所需的投入程度：

- ◆ 只需几分钟：几乎不需要编程，或完全无需编程。
- ◆◆ 约需 20 分钟：通常需要编写并测试少量代码（其中不少题目来源于考试示例）。
- ◆◆◆ 需要较多投入，约 1–2 小时：通常涉及编写和测试较多代码。
- ◆◆◆◆ 实验类作业：需要投入大量时间，可能长达 10 小时。

```c
/* code/intro/hello.c */
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

**图 1** 一个典型的代码示例。

文中的所有代码示例均直接取自使用 gcc 编译并在 Linux 系统上测试过的 C 程序，并经过自动格式化处理，未进行任何人工修改。当然，不同读者的系统可能使用不同版本的 gcc，甚至完全不同的编译器，因此生成的机器代码可能存在差异；但程序的整体行为应当保持一致。所有源代码均可在 CS:APP 官方网站获取（“CS:APP”是本书标题的简称），网址为 `csapp.cs.cmu.edu`。在正文中，源程序的文件名会标注在包围格式化代码的水平分隔线中。例如，图 1 中所示的程序位于 code/intro/ 目录下的 hello.c 文件中。我们鼓励读者在阅读示例程序时，亲自在自己的系统上编译并运行这些代码，以加深理解。

为避免本书在篇幅和内容上过于庞杂，我们引入了一系列网络旁注，用于补充和扩展书中主要内容。这些旁注在正文中以 *chap:top* 的形式引用，其中 *chap* 表示章节主题的简要标识，*top* 表示具体讨论主题的缩写。例如，网络旁注 *data:bool* 提供了布尔代数的补充材料，用于支持第 2 章关于数据表示的讨论；而网络旁注 *arch:vlog* 则介绍了使用 Verilog 硬件描述语言来描述处理器设计的相关内容，作为第 4 章处理器设计部分的扩展。所有网络旁注均可通过 CS:APP 官方网站获取。

> **旁注**
>
> **什么是旁注？**
>
> 你会在整本书中遇到这种形式的旁注。旁注是括号内的评论，为你提供关于当前主题的额外见解。旁注有多种用途。有些是简短的历史课程。例如，C、Linux 和互联网从何而来？其他旁注旨在澄清学生经常感到困惑的概念。例如，高速缓存行、组和块之间有什么区别？其他旁注给出现实世界的例子，比如浮点错误如何导致法国火箭坠毁，或者商用磁盘驱动器的几何和操作参数。最后，有些旁注只是有趣的内容。例如，什么是"hoinky"？

你会在整本书中频繁遇到这种形式的旁注。旁注通常以括号形式出现，用于对当前主题提供补充性的见解与说明。它们用途多样：有的简要回顾相关的历史背景，例如 C 语言、Linux 以及互联网是如何诞生的；有的用于澄清学生常感困惑的概念，比如高速缓存中的行（line）、组（set）与块（block）之间的区别；还有的通过现实世界的案例加深理解，例如浮点数误差如何导致法国火箭坠毁，或商用磁盘驱动器的几何结构与运行参数。当然，也有一些旁注纯粹是为了增添趣味，比如：什么是 “hoinky”？

## 本书概述

CS:APP 全书共 12 章，旨在系统性地提炼和阐释计算机系统的核心思想。以下为各章内容概述。

**第 1 章：计算机系统漫游。** 本章通过追踪一个简单的 “hello, world” 程序从源代码到运行结果的完整生命周期，引出计算机系统中的关键思想与整体主题。

**第 2 章：信息的表示和处理。** 本章系统讲解计算机算术，重点分析无符号数和二进制补码表示中那些直接影响程序员的特性。我们讨论数字如何在给定位宽下表示，从而明确可编码值的范围，并分析有符号数与无符号数相互转换所带来的影响。同时，本章深入探讨算术运算的数学属性。初学者常常会惊讶地发现，两个正数的（二进制补码）和或积可能得到负数；而另一方面，二进制补码算术又满足整数算术的诸多代数性质，使得编译器可以安全地将常数乘法优化为移位与加法序列。我们还利用 C 语言的位级运算展示布尔代数的原理及其应用，并结合 IEEE 浮点数格式讲解浮点数的表示方式及其运算特性。

对计算机算术的深入理解是编写可靠程序的基础。例如，程序员和编译器不能简单地将表达式 `(x < y)` 替换为 `(x - y < 0)`，因为可能发生溢出；同样，也不能替换为 `(-y < -x)`，因为在二进制补码表示中，正数和负数的取值范围并不对称。算术溢出是程序错误和安全漏洞的常见根源，但鲜有书籍能从程序员视角系统阐述计算机算术的这些关键属性。

**第 3 章：程序的机器级表示。** 本章教你阅读 C 编译器生成的 x86-64 机器代码，讲解条件语句、循环和 switch 语句等控制结构对应的基本指令模式。我们详细介绍过程调用的实现机制，包括栈帧分配、寄存器使用约定和参数传递方式，以及结构体、联合体和数组等数据结构的内存布局与访问方法。同时，本章还涵盖整数与浮点算术指令的实现细节，并利用机器级视角分析常见的代码安全漏洞（如缓冲区溢出），以及程序员、编译器和操作系统可采取的防护措施。掌握本章内容将显著提升你对程序运行机制的理解，其中一个直接收益便是对指针形成清晰而具体的认识。

**第 4 章：处理器体系结构。** 本章从基本的组合逻辑和时序逻辑元件出发，逐步展示如何将它们组合成一个能够执行简化 x86-64 指令子集（称为 “Y86-64”）的处理器数据通路。我们首先介绍单周期处理器设计，这种设计概念简单但性能有限；随后引入流水线思想，将指令执行划分为多个独立阶段，使处理器在同一时刻能够并行处理多条指令。最终呈现的五阶段流水线模型更加贴近真实处理器。处理器的控制逻辑采用一种简洁的硬件描述语言 HCL 进行描述。使用 HCL 编写的设计既可以链接到教材配套的模拟器中运行，也可以生成可综合、用于实际硬件实现的 Verilog 描述。

**第 5 章：优化程序性能。** 本章介绍多种提升程序性能的技术，其核心思想是通过合理编写 C 代码，使编译器能够生成更高效的机器代码。我们首先讨论减少程序工作量的基本优化，这是编写任何高性能程序的通用原则；随后进一步介绍如何通过增强指令级并行度来提升程序在现代“超标量”处理器上的执行效率。为此，我们给出了乱序处理器的简化工作模型，并通过分析程序图中的关键路径来评估其潜在性能。你会发现，仅通过一些简单而合理的 C 代码变换，就能获得显著的性能提升。

**第 6 章：存储器层次结构。** 内存系统是计算机系统中对应用程序员最为直观的组成部分之一。此前，你可能将内存视为一个具有统一访问时间的线性数组，而实际上，内存系统由多种容量、成本和访问延迟各异的存储设备构成，形成层次化结构。本章介绍不同类型的 RAM、ROM，以及磁盘和固态硬盘的组织方式，并阐述它们如何组合成存储层次结构。我们通过引用局部性原理解释这一结构的有效性，并以“内存山”的形象模型，将时间局部性和空间局部性的影响具体化。最后，我们展示如何通过改善程序的时间和空间局部性来显著提升应用性能。

**第 7 章：链接。** 本章系统讲解静态链接与动态链接，涵盖可重定位目标文件、可执行文件、符号解析、重定位、静态库、共享库、位置无关代码以及库打桩(用自定义函数替换库中相应的函数)等概念。虽然链接过程在许多系统教材中被忽略，但我们之所以重点介绍它，有两个原因：其一，许多令程序员困惑的错误都源于链接阶段，尤其是在大型软件项目中；其二，链接器生成的目标文件与加载、虚拟内存和内存映射等关键概念密切相关。

**第 8 章：异常控制流。** 本章跳出单程序的顺序执行模型，引入异常控制流这一更一般的概念，即正常分支和过程调用之外的控制流变化。我们从硬件异常和中断讲起，逐步扩展到并发进程之间的上下文切换、Linux 信号引发的控制流突变，以及 C 语言中打破栈纪律的非本地跳转。

本章同时引入了“进程”这一核心抽象概念，即正在执行的程序。你将学习进程的工作机制，以及如何在应用程序中创建和管理它们。我们展示程序员如何通过 Linux 系统调用利用多进程机制，并最终实现一个支持作业控制的简易 Linux shell。这也是你首次直面并发程序执行所带来的非确定性行为。

**第 9 章：虚拟内存。** 本章从工作原理和系统特性两个层面讲解虚拟内存系统。我们希望读者理解多个并发进程如何在各自的虚拟地址空间中运行，既能共享部分页面，又能拥有彼此独立的私有副本。同时，我们还讨论虚拟内存的管理与使用问题，重点介绍动态存储分配器（如标准库中的 malloc 和 free）。这些内容不仅强化了“虚拟内存本质上是一个可划分为不同存储单元的字节数组”的认识，还帮助读者理解内存错误（如内存泄漏和非法指针引用）的影响。许多应用程序员会针对特定需求自行实现存储分配器，而本章正是全书中最能体现软硬件统一视角价值的一章，弥补了传统体系结构与操作系统教材各自只讲一半故事的不足。

**第 10 章：系统级 I/O。** 本章介绍 Unix I/O 的基本概念，包括文件与文件描述符、文件共享、I/O 重定向以及文件元数据的访问方式。我们实现了一个健壮的缓冲 I/O 包，用以正确处理“短计数”这一库函数可能只返回部分数据的特殊情况。同时，本章还讨论 C 标准 I/O 库及其与 Linux I/O 之间的关系，重点分析其在网络编程场景下的局限性。整体而言，本章为后续的网络编程与并发编程奠定了基础。

**第 11 章：网络编程。** 网络作为一种极具代表性的 I/O 设备，将本书前面介绍的诸多概念（如进程、信号、字节序、内存映射和动态内存分配）有机地联系在一起，同时也为并发编程提供了理想的应用背景。本章从客户端—服务器模型出发，讲解程序员视角下的互联网，并详细介绍如何使用套接字接口编写网络客户端与服务器。最后，我们介绍 HTTP 协议，并实现一个简单的迭代式 Web 服务器。

**第 12 章：并发编程。** 本章以互联网服务器设计为贯穿始终的示例，系统介绍并发编程的基本思想。我们比较并分析三种主要并发机制——进程、I/O 多路复用和线程——并展示如何利用它们构建并发网络服务器。同时，详细讲解基于 P、V 操作的信号量同步原理，以及线程安全、可重入性、竞争条件和死锁等关键问题。并发编程是现代服务器应用不可或缺的能力。本章还介绍如何通过线程级并行在多核处理器上提升程序性能，并强调在保证正确性的前提下实现高性能并发执行所需的精细协调。

## 第三版的新内容

本书第一版版权为 2003 年，第二版版权为 2011 年。尽管计算机技术发展迅猛，本书的内容整体上依然保持了良好的时代适用性。基于 Linux（及相关操作系统）在 Intel x86 平台上运行 C 程序，长期以来被证明是一种经典且稳定的组合，至今仍覆盖了大量系统。然而，硬件技术、编译器、程序库接口的持续演进，以及多年来教授这些内容的讲师所积累的教学经验，共同促成了本次幅度较大的修订。

与第二版相比，最显著的整体变化在于：我们将讲解重点从 IA32 与 x86-64 并行的混合体系，全面转向以 x86-64 为唯一基础。这一转变影响了书中多个章节。以下是本次修订的主要变化概述。

**第 1 章：计算机系统漫游。**
我们将阿姆达尔定律的讨论从第 5 章前移至本章。

**第 2 章：信息的表示和处理。**
读者与评审者普遍反馈，本章部分内容理解难度较高。基于此，我们对内容结构进行了重组，并进一步阐明采用偏数学化表述方式的动机，以提升整体可读性。读者可先略过具体的数学细节，把握整体思路，再回过头深入研读相关推导与论证。

**第 3 章：程序的机器级表示。**
本章从早期 IA32 与 x86-64 混合讲解，全面转为基于 x86-64 的体系结构。同时，我们针对较新版本 gcc 的代码生成风格进行了更新。由此带来了大规模重写，包括调整部分概念的呈现顺序。此外，本章首次加入了对浮点数据操作程序的机器级支持讲解，并以网络旁注的形式保留了 IA32 机器代码的说明，供遗留参考。

**第 4 章：处理器体系结构。**
我们将原先基于 32 位架构的处理器设计，修订为支持 64 位字长与操作的体系结构。

**第 5 章：优化程序性能。**
本章内容更新以反映近几代 x86-64 处理器的性能特征。随着更多功能单元和更复杂控制逻辑的引入，基于程序数据流表示所建立的性能模型，相比以往已成为更可靠的性能预测工具。

**第 6 章：存储器层次结构。**
我们对相关内容进行了更新，以体现最新的存储技术发展。

**第 7 章：链接。**
本章针对 x86-64 体系进行了重写，扩展了对使用 GOT 和 PLT 构建位置无关代码的讨论，并新增了一节内容，介绍一种称为“库打桩”的强大链接技术。

**第 8 章：异常控制流。**
我们加强了对信号处理程序的讲解，包括异步信号安全函数、编写信号处理程序的具体准则，以及使用 `sigsuspend` 等机制等待信号处理完成的方法。

**第 9 章：虚拟内存。**
本章仅做了少量修改。

**第 10 章：系统级 I/O。**
我们新增了关于文件及文件层次结构的内容，其余部分仅有轻微调整。

**第 11 章：网络编程。**
本章引入了使用现代 `getaddrinfo` 和 `getnameinfo` 函数进行协议无关、线程安全网络编程的方法，以取代已过时且不可重入的 `gethostbyname` 和 `gethostbyaddr`。

**第 12 章：并发编程。**
我们扩充了相关内容，更系统地介绍如何利用线程级并行性，使程序在多核处理器上获得更高性能。

此外，全书范围内新增并修订了大量练习题和家庭作业，以更好地支持教学与自学。

## 本书的起源

本书源于我们于 1998 年秋季在卡内基梅隆大学（CMU）开发的一门入门课程——**15-213：计算机系统导论**（ICS）[14]。自那时起，ICS 每学期持续开设，每学期选课人数超过 400 人，学生群体涵盖大二本科生至来自不同专业的研究生。该课程是 CMU 计算机科学系以及电子与计算机工程系所有本科生的必修核心课程，并已成为两系多数高年级系统课程的先修课。

ICS 的教学理念在于以一种不同于传统路径的方式向学生介绍计算机系统。我们的学生中，真正有机会从零构建完整计算机系统的人寥寥无几；然而，几乎所有学生——尤其是计算机科学家和计算机工程师——都需要在日常学习与工作中使用计算机并进行编程。因此，我们选择从**程序员的视角**来讲授系统，并遵循如下原则：**只覆盖那些会影响用户级 C 程序性能、正确性或实用性的主题**。

基于这一原则，诸如硬件加法器或总线设计等内容被有意排除；而机器语言相关主题则被纳入讨论，但重点并非手写汇编代码，而是理解 **C 编译器如何将 C 语言结构映射为机器代码**，包括指针、循环、过程调用以及 `switch` 语句等。同时，我们采取一种更为宏观、整体的系统观，将计算机系统视为硬件与系统软件的统一体，系统性地涵盖链接与加载、进程与信号、性能优化、虚拟内存、I/O，以及网络与并发编程等关键主题。

这种教学方法使我们能够以**实用、具体、动手且富有吸引力**的方式讲授 ICS 课程。来自学生与教师同事的反馈迅速而且极为积极，这促使我们意识到：CMU 之外的更多读者同样可以从这种方法中获益。正因如此，本书应运而生——它源自 ICS 的课程讲义，并在此基础上不断修订，以反映技术发展以及计算机系统实现方式的演进。

随着本书多个版本的出版及多种语言的翻译，ICS 及其众多变体课程已被全球数百所学院和大学采纳，成为计算机科学与计算机工程教学体系中的重要组成部分。

## 给教师：基于本书的课程

教师可以基于 **CS:APP** 一书讲授多种不同类型的系统课程。这些课程可分为五类，如图 2 所示。具体选择取决于课程目标、教师的个人偏好以及学生的背景与能力。总体而言，图中从左到右的课程逐步增强了对**系统的程序员视角**的强调。下面对各类课程作简要说明。

**ORG。** 一门以非传统方式讲授传统内容的计算机组成原理课程，涵盖逻辑设计、处理器体系结构、汇编语言和存储系统等经典主题，但更侧重这些内容对程序员的影响。例如，将数据表示与 C 语言的数据类型和操作相联系；汇编代码的讲解基于 C 编译器生成的机器代码，而非手写汇编程序。

**ORG+。** 在 ORG 的基础上，进一步强调硬件对应用程序性能的影响。与 ORG 相比，学生将更多地学习代码优化方法，以及如何提升 C 程序的内存性能。

**ICS。** 基线版的 ICS 课程，旨在培养“开明的程序员”，使其理解硬件、操作系统和编译系统如何影响应用程序的性能与正确性。与 ORG+ 的一个重要区别在于，该课程不涉及低级处理器体系结构，而是让程序员基于现代乱序处理器的更高层抽象模型进行学习。ICS 课程非常适合 10 周制学季；若教学节奏更为从容，也可扩展为 15 周制学期。

**ICS+。** 在基线 ICS 课程之上，增加系统编程主题的深入讲解，包括系统级 I/O、网络编程和并发编程等。这是卡内基梅隆大学的一门一学期课程，覆盖了 **CS:APP** 中除低级处理器体系结构以外的全部章节。

| 章节 | 主题 | ORG | ORG+ | ICS | ICS+ | SP |
|------|------|------|-----|------|-----|------|
| 1 | 系统漫游 | • | • | • | • | • |
| 2 | 数据表示 | • | • | • | • | ⊙(d) |
| 3 | 机器语言 | • | • | • | • | • |
| 4 | 处理器架构 | • | • | | | |
| 5 | 代码优化 | | • | • | • | |
| 6 | 存储器层次结构 | ⊙(a) | • | • | • | ⊙(a) |
| 7 | 链接 | | | ⊙(c) | ⊙(c) | • |
| 8 | 异常控制流 | | | • | • | • |
| 9 | 虚拟内存 | ⊙(b) | • | • | • | • |
| 10 | 系统级 I/O | | | | • | • |
| 11 | 网络编程 | | | | • | • |
| 12 | 并发编程 | | | | • | • |

**图 2** 基于 CS:APP 一书设计的五门系统课程。ICS+ 对应卡内基梅隆大学的 15-213 课程。注：⊙ 符号表示仅涵盖某一章节的部分内容，具体含义如下：(a) 仅涉及硬件；(b) 不包含动态存储分配；(c) 不包含动态链接；(d) 不包含浮点运算。

**SP。** 系统编程课程。该课程与 ICS+ 类似，但去除了浮点运算和性能优化内容，更加侧重系统编程主题，包括进程控制、动态链接、系统级 I/O、网络编程以及并发编程。教师也可根据需要从其他资料中补充高级主题，如守护进程、终端控制以及 Unix IPC。

图 2 的核心信息在于： CS:APP 为学生和教师提供了高度灵活的课程选择。如果希望学生深入理解底层处理器体系结构，可以选择 ORG 或 ORG+ 课程。另一方面，若计划从现有的计算机组成原理课程过渡到 ICS 或 ICS+，但又对一次性进行大幅调整持谨慎态度，则可以采取循序渐进的方式向 ICS 靠拢：先从 ORG 开始，以一种非传统的方式讲授传统主题；在熟悉相关材料之后，再过渡到 ORG+，最终引入 ICS。若学生缺乏 C 语言基础（例如仅使用 Java 进行编程），可以先安排数周时间学习 C 语言，再进入 ORG 或 ICS 的相关内容。

最后需要指出的是，ORG+ 与 SP 可以构成一个非常理想的两学期课程序列（无论采用学季制还是学期制）。此外，也可以将 ICS+ 拆分为一学期的 ICS 与一学期的 SP 来开设。


## 给教师：经过课堂检验的实验练习

卡内基梅隆大学的 ICS+ 课程获得了学生的高度评价。学生课程评估的中位数达到 **5.0/5.0**，平均评分也稳定在 **4.6/5.0**。学生普遍认为，课程中**有趣、富有挑战性且紧密贴合实际的实验练习**是获得高评价的主要原因。所有实验均可从 CS:APP 官方网页获取。以下列举了本书提供的部分实验示例。

**数据实验（Data Lab）。**
该实验要求学生在高度受限的 C 语言子集中实现简单的逻辑与算术函数。例如，只能使用位级操作来计算整数的绝对值。通过该实验，学生能够深入理解 C 语言数据类型的位级表示，以及数据在位级层面的操作行为。

**二进制炸弹实验（Binary Bomb Lab）。**
二进制炸弹以目标代码文件的形式提供给学生。程序运行时会要求输入六个不同的字符串，只要其中任意一个不正确，炸弹就会“爆炸”，打印错误信息并在评分服务器上记录事件。学生必须通过反汇编和逆向工程来“拆除”各自独一无二的炸弹，推断出正确的六个字符串。该实验帮助学生理解汇编语言，并促使他们熟练掌握调试器的使用。

**缓冲区溢出实验（Buffer Overflow Lab）。**
学生需要利用缓冲区溢出漏洞来改变二进制可执行文件的运行时行为。该实验系统地讲解了栈的工作机制，并直观展示了编写存在缓冲区溢出风险代码所带来的安全隐患。

**架构实验（Architecture Lab）。**
第 4 章中的若干家庭作业可组合为一个完整实验，学生通过修改处理器的 HCL 描述来添加新指令、调整分支预测策略，或增删旁路路径与寄存器端口。生成的处理器可在模拟器中运行，并通过自动化测试验证，大多数潜在错误都会被检测出来。该实验让学生在无需完整逻辑设计和硬件描述语言背景的情况下，体验处理器设计中最具吸引力的部分。

**性能实验（Performance Lab）。**
学生需要优化应用程序中核心函数的性能，例如卷积运算或矩阵转置。该实验清晰地展示了高速缓存存储器的特性，并帮助学生积累底层程序性能优化的实践经验。

**缓存实验（Cache Lab）。**
作为性能实验的一种替代方案，学生首先实现一个通用的缓存模拟器，然后对一个小型矩阵转置内核进行优化，以尽量减少模拟缓存中的缺失次数。实验中使用 Valgrind 工具为矩阵转置内核生成真实的地址访问轨迹。

**Shell 实验（Shell Lab）。**
学生实现一个具备作业控制功能的 Unix shell，支持 Ctrl+C、Ctrl+Z 以及 `fg`、`bg`、`jobs` 等命令。这通常是学生首次系统接触并发编程，使他们对 Unix 进程控制、信号及信号处理机制形成直观而深入的理解。

**Malloc 实验（Malloc Lab）。**
学生实现自己版本的 `malloc`、`free`，以及（可选的）`realloc`。该实验帮助学生深入理解内存中数据的布局与组织方式，并要求他们在空间效率与时间效率之间进行权衡与取舍。

**代理实验（Proxy Lab）。**
学生实现一个并发 Web 代理，位于浏览器与万维网其余部分之间。该实验使学生接触 Web 客户端与服务器等主题，并将课程中的多项核心概念有机结合起来，包括字节序、文件 I/O、进程控制、信号与信号处理、内存映射、套接字以及并发。学生尤为喜欢看到自己编写的程序能够与真实的 Web 浏览器和 Web 服务器协同工作。

CS:APP 教师手册对上述实验进行了更为详尽的讨论，并提供了配套支持软件的下载说明。

## 第三版致谢

很高兴在此致谢，感谢所有为 CS:APP 第三版的编写与完善提供帮助的人们。

首先，我们要感谢多年来在卡内基梅隆大学教授 ICS 课程的同事们。正是他们持续不断、富有洞见的反馈与鼓励，极大地促进了本书的改进与提升。他们是：Guy Blelloch、Roger Dannenberg、David Eckhardt、Franz Franchetti、Greg Ganger、Seth Goldstein、Khaled Harras、Greg Kesden、Bruce Maggs、Todd Mowry、Andreas Nowatzyk、Frank Pfenning、Markus Pueschel 以及 Anthony Rowe。我们还特别感谢 David Winters 在参考 Linux 机器的安装与配置方面给予的鼎力支持。

Jason Fritts（圣路易斯大学）和 Cindy Norris（阿巴拉契亚州立大学）为第二版提供了详尽而深思熟虑的评审意见。龚益力（武汉大学）完成了中文版翻译，维护了中文版的勘误页面，并提交了大量宝贵的错误报告。Godmar Back（弗吉尼亚理工大学）通过向我们介绍异步信号安全以及与协议无关的网络编程思想，帮助我们对文本内容进行了显著改进。

我们衷心感谢所有在第二版中报告错误的细心读者：Rami Ammari、Paul Anagnostopoulos、Lucas Bärenfänger、Godmar Back、Ji Bin、Sharbel Bousemaan、Richard Callahan、Seth Chaiken、Cheng Chen、Libo Chen、Tao Du、Pascal Garcia、Yili Gong、Ronald Greenberg、Dorukhan Gülöz、Dong Han、Dominik Helm、Ronald Jones、Mustafa Kazdagli、Gordon Kindlmann、Sankar Krishnan、Kanak Kshetri、Junlin Lu、Qiangqiang Luo、Sebastian Luy、Lei Ma、Ashwin Nanjappa、Gregoire Paradis、Jonas Pfenninger、Karl Pichotta、David Ramsey、Kaustabh Roy、David Selvaraj、Sankar Shanmugam、Dominique Smulkowska、Dag Sørbø、Michael Spear、Yu Tanaka、Steven Tricanowicz、Scott Wright、Waiki Wright、Han Xu、Zhengshan Yan、Firo Yang、Shuang Yang、John Ye、Taketo Yoshida、Yan Zhu 以及 Michael Zink。

同时，我们也感谢为实验内容做出贡献的读者，包括：Godmar Back（弗吉尼亚理工大学）、Taymon Beal（伍斯特理工学院）、Aran Clauson（西华盛顿大学）、Cary Gray（惠顿学院）、Paul Haiduk（西德克萨斯农工大学）、Len Hamey（麦考瑞大学）、Eddie Kohler（哈佛大学）、Hugh Lauer（伍斯特理工学院）、Robert Marmorstein（朗伍德大学）以及 James Riely（德保罗大学）。

我们再次感谢 Windfall Software 的 Paul Anagnostopoulos 出色地完成了本书的排版工作并统筹了整个制作流程。同时，也向他所带领的优秀团队致以诚挚谢意：Richard Camp（文字编辑）、Jennifer McClain（校对）、Laurel Muller（美术制作）以及 Ted Laux（索引制作）。值得一提的是，Paul 甚至发现了我们对 BSS 这一首字母缩写词起源描述中的错误——这一问题自第一版以来一直未被察觉。

最后，我们要感谢 Prentice Hall 的朋友们。Marcia Horton 以及我们的编辑 Matt Goldstein 始终给予我们坚定的支持与鼓励，在此谨致以最诚挚的谢意。

## 第二版致谢

我们谨向所有帮助我们完成 **CS:APP 第二版** 的朋友致以诚挚而深切的感谢。

首先，感谢在卡内基梅隆大学教授 ICS 课程的同事们。他们提供了极具洞察力的反馈与持续的鼓励，受益匪浅：Guy Blelloch、Roger Dannenberg、David Eckhardt、Greg Ganger、Seth Goldstein、Greg Kesden、Bruce Maggs、Todd Mowry、Andreas Nowatzyk、Frank Pfenning 和 Markus Pueschel。

同时，感谢为第一版勘误页做出重要贡献的细心读者：Daniel Amelang、Rui Baptista、Quarup Barreirinhas、Michael Bombyk、Jörg Brauer、Jordan Brough、Yixin Cao、James Caroll、Rui Carvalho、Hyoung-Kee Choi、Al Davis、Grant Davis、Christian Dufour、Mao Fan、Tim Freeman、Inge Frick、Max Gebhardt、Jeff Goldblat、Thomas Gross、Anita Gupta、John Hampton、Hiep Hong、Greg Israelsen、Ronald Jones、Haudy Kazemi、Brian Kell、Constantine Kousoulis、Sacha Krakowiak、Arun Krishnaswamy、Martin Kulas、Michael Li、Zeyang Li、Ricky Liu、Mario Lo Conte、Dirk Maas、Devon Macey、Carl Marcinik、Will Marrero、Simone Martins、Tao Men、Mark Morrissey、Venkata Naidu、Bhas Nalabothula、Thomas Niemann、Eric Peskin、David Po、Anne Rogers、John Ross、Michael Scott、Seiki、Ray Shih、Darren Shultz、Erik Silkensen、Suryanto、Emil Tarazi、Nawanan Theera-Ampornpunt、Joe Trdinich、Michael Trigoboff、James Troup、Martin Vopatek、Alan West、Betsy Wolff、Tim Wong、James Woodruff、Scott Wright、Jackie Xiao、Guanpeng Xu、Qing Xu、Caren Yang、Yin Yongsheng、Wang Yuanxuan、Steven Zhang 和 Day Zhong。特别感谢 Inge Frick，他在锁与复制示例中发现了一个极其微妙的深拷贝错误；也特别感谢 Ricky Liu，其令人赞叹的校对能力为文本质量提供了有力保障。

在本书的整个编写过程中，我们的 Intel Labs 同事 Andrew Chien 和 Limor Fix 给予了持续而有力的支持。Steve Schlosser 慷慨分享了若干磁盘驱动器特性数据。Casey Helfrich 与 Michael Ryan 负责新 Core i7 机器的安装与维护。Michael Kozuch、Babu Pillai 和 Jason Campbell 就内存系统性能、多核系统以及“功耗墙”等问题提供了宝贵见解。Phil Gibbons 与 Shimin Chen 分享了他们在固态硬盘设计方面的深厚专业经验。

我们也得益于许多杰出学者的智慧与才能，其中包括 Wen-Mei Hwu、Markus Pueschel 和 Jiri Simsa，他们提供了详尽的评注与高层次建议。James Hoe 协助我们完成了 Y86 处理器的 Verilog 实现，并承担了将其综合为可工作的硬件所需的全部工作。

衷心感谢对手稿草案进行评审的同事们：James Archibald（杨百翰大学）、Richard Carver（乔治梅森大学）、Mirela Damian（维拉诺瓦大学）、Peter Dinda（西北大学）、John Fiore（天普大学）、Jason Fritts（圣路易斯大学）、John Greiner（莱斯大学）、Brian Harvey（加州大学伯克利分校）、Don Heller（宾夕法尼亚州立大学）、Wei Chung Hsu（明尼苏达大学）、Michelle Hugue（马里兰大学）、Jeremy Johnson（德雷塞尔大学）、Geoff Kuenning（哈维穆德学院）、Ricky Liu、Sam Madden（麻省理工学院）、Fred Martin（马萨诸塞大学洛厄尔分校）、Abraham Matta（波士顿大学）、Markus Pueschel（卡内基梅隆大学）、Norman Ramsey（塔夫茨大学）、Glenn Reinmann（加州大学洛杉矶分校）、Michela Taufer（特拉华大学）以及 Craig Zilles（伊利诺伊大学厄巴纳—香槟分校）。

Windfall Software 的 Paul Anagnostopoulos 出色地完成了本书的排版工作，并领导了制作团队。在此特别感谢 Paul 及其卓越的团队成员：Rick Camp（文字编辑）、Joe Snowden（排版）、MaryEllen N. Oliver（校对）、Laurel Muller（美术设计）和 Ted Laux（索引）。

最后，谨向 Prentice Hall 的朋友们致以诚挚感谢。Marcia Horton 始终给予我们坚定支持；编辑 Matt Goldstein 从始至终提供了卓越的领导力。我们对他们的帮助、鼓励与深刻洞察心怀感激。

## 第一版致谢

我们衷心感谢许多朋友和同事的深思熟虑的批评与鼓励，特别是我们的 15-213 学生，他们的热情与活力激励我们不断前行。Nick Carter 和 Vinny Furia 慷慨提供了他们的 malloc 包。

Guy Blelloch、Greg Kesden、Bruce Maggs 和 Todd Mowry 在多个学期里教授了这门课程，给予我们鼓励并帮助改进课程材料。Herb Derby 提供了早期的精神指导与鼓励。Allan Fisher、Garth Gibson、Thomas Gross、Satya、Peter Steenkiste 和 Hui Zhang 从一开始便鼓励我们开发这门课程。Garth 早期的一个建议为整个项目的启动铺平了道路，后来由 Allan Fisher 领导的小组接手并完善了该项目。Mark Stehlik 和 Peter Lee 非常支持将这些材料纳入本科课程。Greg Kesden 提供了有益的反馈，探讨了 ICS 对操作系统课程的影响。Greg Ganger 和 Jiri Schindler 慷慨地提供了磁盘驱动器特性数据，并解答了我们关于现代磁盘的相关问题。Tom Stricker 向我们展示了内存山。James Hoe 提供了关于如何呈现处理器架构的有益建议与反馈。

特别感谢一群杰出的学生——Khalil Amiri、Angela Demke Brown、Chris Colohan、Jason Crawford、Peter Dinda、Julio Lopez、Bruce Lowekamp、Jeff Pierce、Sanjay Rao、Balaji Sarpeshkar、Blake Scholl、Sanjit Seshia、Greg Steffan、Tiankai Tu、Kip Walker 和 Yinglian Xie——他们在帮助我们开发课程内容方面发挥了重要作用。特别是，Chris Colohan 创造了延续至今的有趣（且搞笑）的基调，并发明了传奇的"二进制炸弹"，这已成为教授机器代码和调试概念的绝佳工具。

Chris Bauer、Alan Cox、Peter Dinda、Sandhya Dwarkadas、John Greiner、Don Heller、Bruce Jacob、Barry Johnson、Bruce Lowekamp、Greg Morrisett、Brian Noble、Bobbie Othmer、Bill Pugh、Michael Scott、Mark Smotherman、Greg Steffan 和 Bob Wier 不辞辛劳地阅读并为本书的早期草稿提出了宝贵的建议。特别感谢 Al Davis（犹他大学）、Peter Dinda（西北大学）、John Greiner（莱斯大学）、Wei Hsu（明尼苏达大学）、Bruce Lowekamp（威廉与玛丽学院）、Bobbie Othmer（明尼苏达大学）、Michael Scott（罗彻斯特大学）和 Bob Wier（落基山学院）对测试版进行的课堂测试。同时也感谢他们的学生！

我们还要感谢 Prentice Hall 的同事们。Marcia Horton、Eric Frank 和 Harold Stone 一直坚定不移地支持我们的愿景。Harold 还帮助我们准确呈现了 RISC 和 CISC 处理器架构的历史视角。Jerry Ralya 提供了敏锐的见解，并教会了我们许多关于优秀写作的知识。

最后，我们要感谢伟大的技术作家 Brian Kernighan 和已故的 W. Richard Stevens，他们向我们展示了技术书籍也能如此美丽。

谢谢大家。

Randy Bryant  
Dave O'Hallaron  
匹兹堡，宾夕法尼亚州

Pearson 特别感谢并致谢 MS Ramaiah Institute of Technology 的 Chetan Venkatesh、Don Bosco College 的 Desny Antony 和 SP College 的 Chitra Dhawale 对全球版的评审。

---

## 本章小结

本前言介绍了《深入理解计算机系统》(CS:APP) 的核心理念和使用方法：

- **定位与目标**：本书从程序员的角度讲解计算机系统，旨在帮助读者深入理解底层原理，从而编写更高效的程序。
- **读者背景**：假设读者已具备 C/C++ 编程基础，本书聚焦于 x86-64 架构和 Linux 系统。
- **学习方法**：强调“做中学”——通过练习题、家庭作业与实验，帮助读者牢固掌握核心概念。
- **内容结构**：全书共计 12 章，内容涵盖数据表示、机器代码、处理器架构、内存层次、链接、异常控制流、虚拟内存、I/O、网络编程和并发编程等领域。
- **课程灵活性**：可根据教学需求调整为不同类型的课程，如 ORG、ORG+、ICS、ICS+ 或 SP 等。
- **配套实验**：包含经典实验，如 Data Lab、Binary Bomb Lab、Buffer Overflow Lab 等，帮助读者通过实践加深理解。

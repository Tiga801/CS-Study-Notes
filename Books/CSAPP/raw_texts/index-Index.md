# Chapter index: Index

> **中文标题**: 索引
> **页码范围**: 1074-1105
> **OCR 提取**: PaddleOCR-VL-1.5

---

<!-- Page 1074 -->

# Index

Page numbers of defining references are italicized. Entries that belong to a hardware or software system are followed by a tag in brackets that identifies the system, along with a brief description to jog your memory. Here is the list of tags and their meanings.

[C] ___ C language construct

[C Stdlib] C standard library function

[CS:APP] Program or function developed in this text

[HCl] HCl language construct

[Unix] Unix program, function, variable, or constant

[x86-64] x86-64 machine-language instruction

[Y86-64] Y86-64 machine-language instruction

! [HCL] not operation, 409

$ for immediate operands, 217

& [C] address of operation local variables, 284 logic gates, 409 pointers, 84, 224, 293, 313

* [C] dereference pointer operation, 224

-> [C] dereference and select field operation, 302

.(periods) in dotted-decimal notation, 962

|| [HCL] or operation, 409

< operator for left hoinkies, 945

<< "put to" operator (C++), 926

> operator for right hoinkies, 945

>> “get from” operator (C++), 926

 $ ^{+t}_{w} $ (two's-complement addition), 96, 126

 $ ^{*} $ $ _{w} $ (two's-complement multiplication), 96, 133

 $ -_{w}^{t} $ (two's-complement negation), 96, 131

 $ ^{+u}_{w} $ (unsigned addition), 96, 121, 125

 $ ^{*} $ $ ^{u} $ (unsigned multiplication), 96, 132

 $ -^{u}_{w} $ (unsigned negation), 96, 125

8086 microprocessor, 203

8087 floating-point coprocessor, 145, 173, 203

80286 microprocessor, 203

. a archive files, 722

a. out object file, 709

Abel, Niels Henrik, 125

abelian group, 125

ABI (application binary interface), 346

abort exception class, 762

aborts, 764

absolute addressing relocation type, 727, 729–730

absolute pathnames, 929

absolute speedup of parallel programs,

1055

abstract operation model for Core i7, 561–567

abstractions, 63

accept [Unix] wait for client connection request, 969, 972, 972–973

access

disks, 633–636

IA32 registers, 215–216

main memory, 623–625

x86-64 registers

data movement, 218–225

operand specifiers, 216–218

access permission bits, 930

access time for disks, 629, 629–631

accumulator variable expansion, 60

accumulators, multiple, 572–577

Acorn RISC machine (ARM)

ISAs, 388

processor architecture, 399

actions, signal, 798

active sockets, 971

actuator arms, 628

acyclic networks, 410

adapters, 45, 633

ADD [instruction class] add, 228

add_client function, 1017, 1019

add every signal to signal set instruction, 801

add instruction, 228

ADD operation in execute stage, 444

add signal to signal set instruction, 80

adder [CS:APP] CGI adder, 991

addition

floating point, 158–160, 338

two's complement, 126, 126–131

unsigned, 120–126, 121

Y86-64, 392

additive inverse, 88

---

<!-- Page 1075 -->

addq [Y86-64] add, 392, 438

address exceptions, status code for,

440

address of operator (&) [C]

local variables, 284

logic gates, 409

pointers, 84, 224, 293, 313

address order of free lists, 899

address partitioning in caches, 651, 651–652

address-space layout randomization (ASLR), 321, 321–322

address spaces, 840

address spaces, 840

child processes, 777

linear, 840

private, 770

virtual, 840–841

ddress translation, 840

caches and VM integration, 853

Core i7, 862–864

end-to-end, 857–861

multi-level page tables, 855–857

optimizing, 866

overview, 849–852

TLBs for, 853–855

dresses and addressing

byte ordering, 78–85

effective, 726

flat, 203

internet, 958

invalid address status code, 400

I/O devices, 634

IP, 960, 961–963

machine-level programming, 206–207

operands, 217

out of bounds. See buffer overflow

physical vs. virtual, 839–840

procedure return, 276

segmented, 323–324

sockets, 966, 969–970

structures, 301–303

symbol relocation, 726–727

virtual, 840

virtual memory, 70

addressing modes, 217

djacency matrices, 696

DR [Y86-64] status code indicating invalid address, 400

advanced Micro Devices (AMD), 201, 204

Intel compatibility, 204

x86-64. See x86-64 microprocessors

Advanced Research Projects

Administration (ARPA), 967



advanced vector extensions (AVX)

instructions, 330, 582–583

AFS (Andrew File System), 646

aggregate data types, 207

aggregate payloads, 881

%al [x86-64] low order 8 of register %rax, 216

alarm [Unix] schedule alarm to self,

798, 799

algebra, Boolean, 86–89, 88

aliasing memory, 535, 536

.align directive, 402

alignment

data, 309, 309–312

memory blocks, 880

alloca [Unix] stack storage allocation function, 321, 326, 360

allocate and initialize bounded buffer function, 1043

allocate heap block function, 896, 897

allocate heap storage function, 876

allocated bit, 884

allocated blocks

vs. free, 875

placement, 885

allocation

blocks, 896

dynamic memory. See dynamic

memory allocation

pages, 846

allocators

block allocation, 896

block freeing and coalescing, 896

free list creation, 893–895

free list manipulation, 892–893

general design, 890–892

practice problems, 897–898

requirements and goals, 880–881

styles, 875–876

Alpha (Compaq Computer Corp.) RISC processors, 399

alternate representations of signed

integers, 104

ALUADD [Y86-64] function code for addq instruction, 440

ALUs (arithmetic/logic units), 46

combinational circuits, 416

in execute stage, 421

sequential Y86-64 implementation,

444–445

always taken branch prediction strategy, 464

AMD (Advanced Micro Devices), 201, 204

Intel compatibility, 204

microprocessor data alignment, 312

x86-64. See x86-64 microprocessors



Amdahl, Gene, 58

Amdahl's law, 58, 58–60, 598, 604

American National Standards

Institute (ANSI), 40, 71

ampersands (&) address operator, 284

local addresses, 284

logic gates, 409

pointers, 84, 224, 293, 313

AND [instruction class] and, 228

and instruction, 228

AND operations

Boolean, 87–88

execute stage, 444

HCL expressions, 410–411

logic gates, 409

logical, 92–93

AND packed double precision instruction, 341

AND packed single precision instruction, 341

andq [Y86-64] and, 392

Andreesen, Marc, 985

Andrew File System (AFS), 646

anonymous files, 869

ANSI (American National Standards Institute), 40, 71

AOK [Y86-64] status code for normal operation, 399

app_error [CS:APP] reports application errors, 1079

application binary interface (ABI), 346

applications, loading and linking

shared libraries from, 737–739

AR Linux archiver, 722, 749

arbitrary size arithmetic, 121

Archimedes, 176

architecture

floating-point, 329, 329–332

Y86. See Y86-64 instruction set

architecture

archives, 722

areal density of disks, 627

areas

shared, 870

swap, 869

virtual memory, 866

arguments

execve function, 786

Web servers, 989–990

---

<!-- Page 1076 -->

arithmetic, 69, 227

discussion, 232–233

floating-point code, 338–340

integer. See integer arithmetic

latency and issue time, 559

load effective address, 227–229

pointers, 293–294, 909

saturating, 170

shift operations, 94, 140–142, 228

230–232

special, 233–236

unary and binary, 230–232

arithmetic/logic units (ALUs), 46

combinational circuits, 416

in execute stage, 421

sequential Y86-64 implementation,

444–445

ARM (Acorn RISC machine), 79

ISAs, 388

processor architecture, 399

ARM A7 microprocessor, 389

arms, actuator, 628

ARPA (Advanced Research Projects Administration), 967

ARPANET, 967

arrays, 291

basic principles, 291–293

declarations, 291–292, 299

DRAM, 618

fixed-size, 296–298

machine-code representation,

nested, 294–296

pointer arithmetic, 293–294

pointer relationships, 84, 313

stride, 642

variable-size, 298–301

ASCII standard, 39

character codes, 85

limitations, 86

as time function, 1060

ASLR (address-space layout randomization), 321, 321–322

asm directive, 214

assembler directives, 402

assemblers, 41, 41, 200, 206

assembly code, 41, 200

with C programs, 325–326

formatting, 211–213

Y86-64, 395

assembly phase, 41

associate socket address with

descriptor function, 971, 971

associative caches, 660–662

associative memory, 661

associativity

caches, 669

floating-point addition, 159–160

asterisks (*) dereference pointer operation, 224, 293, 313

asymmetric ranges in two's-complement representation, 102, 113

async-signal-safe function, 802

async-signal safety, 802

asynchronous interrupts, 762

atomic reads and writes, 806

ATT assembly code format, 213, 330, 347

argument listing, 342

condition codes, 237–238

cqo instruction, 235

vs. Intel, 213

operands, 217, 228

Y86-64, 392

automatic variables, 1030

AVX (advanced vector extensions)

instructions, 312, 330, 582–583

%ax [x86-64] low order 16 bits of register %rax, 216

B2T (binary to two's-complement conversion), 96, 100, 108, 133

B2U (binary to unsigned conversion), 96, 98, 108, 118, 133

background processes, 789, 789–792

backlogs for listening sockets, 971

backups for disks, 647

backward compatibility, 71

backward taken, forward not taken (BTFNT) branch prediction strategy, 464

bad pointers and virtual memory, 906–907

badcnt.c [CS:APP] improperly synchronized program, 1031–1035, 1032

bandwidth, read, 675

Barracuda 7400 drives, 636

base pointers, 326

base registers, 217

bash [Unix] Unix shell program, 789

basic blocks, 605

Bell Laboratories, 71

Berkeley sockets, 968

Berners-Lee, Tim, 985

best-fit block placement policy, 885, 885

bi-endian ordering convention, 79

biased number encoding, 149, 149–153

biasing in division, 142

big-endian ordering convention, 78,

78–80

bigrams statistics, 601



bijections, 100, 100

/bin/kill program, 796

binary files, 39, 927

binary notation, 68

binary points, 146, 146–147

binary representations

conversions

with hexadecimal, 72–73

signed and unsigned, 106–11

to two’s complement, 100,

108–109, 133

to unsigned, 98–99

fractional, 145–148

machine language, 230

binary semaphores, 1039

binary tree structure, 306–307

bind [Unix] associate socket address with descriptor, 969, 971, 971

binding, lazy, 742

bistable memory cells, 617

t-level operations, 90–92

bit representation expansion, 112–1

bit vectors, 87, 87–88

bits, 39

overview, 68

union access to, 307–308

bitwise operations, 341–342

%b1 [x86-64] low order 8 of register %rbx, 216

block and unblock signals instruction

801

block devices, 928

block pointers, 892

block size

caches, 669

minimum, 884

blocked bit vectors, 795

blocked signals, 794, 795, 800–801

blocking

signals, 800–801

for temporal locality, 683

blocks

aligning, 880

allocated, 875, 885

vs. cache lines, 670

caches, 647, 647–648, 651, 669

coalescing, 886–887, 896

epilogue, 891

free lists, 883–885

freeing, 896

heap, 875

logical disk, 631, 631–632, 637

prologue, 891

prologue, 891

---

<!-- Page 1077 -->

referencing data in, 910–911

splitting, 885–886

podies, response, 988

pool [HCL] bit-level signal, 410

Boole, George, 86

Boolean algebra and functions, 86

HCL, 410–411

logic gates, 409

properties, 88

working with, 86–89

Boolean rings, 88

bottlenecks, 598

profilers, 601–604

program profiling, 598–600

bottom of stack, 226

boundary tags, 887, 887–890, 895

bounded buffers, 1040, 1041–1042

bounds

latency, 554, 560

throughput, 554, 560

%bp [x86-64] low order 16 bits of register %rbp, 216

%bp1 [x86-64] low order 8 of register %rbp, 216

branch prediction, 555, 555

misprediction handling, 479–480

performance, 585–589

Y86-64 pipelining, 464

branch prediction logic, 251

branches, conditional, 208, 245

assembly form, 247

condition codes, 237–238

condition control, 245–249

moves, 250–256, 586–589

switch, 268–274

break command

in GDB, 316

with switch, 269

break multstore command in GDB, 316

breakpoints, 315–316

bridged Ethernet, 956, 957

bridges

Ethernet, 956

I/O, 623

browsers, 984, 985

.bss section, 710

BTFNT (backward taken, forward not taken) branch prediction strategy, 464

bubbles, pipeline, 470, 470–471, 495–496

buddies, 901

buddy systems, 901, 901

buffer overflow, 315

execution code regions limits for, 325–326

memory-related bugs, 907

overview, 315–320

stack corruption detection for, 322–325

stack randomization for, 320–322

vulnerabilities, 43

buffered I/O functions, 934–938

buffers

bounded, 1040, 1041–1042

read, 934, 936–937

store, 593–594

streams, 947

bus transactions, 623

buses, 44, 623

designs, 624, 634

I/O, 632

memory, 623

bypassing for data hazards, 472–475

byte data connections in hardware diagrams, 434

byte order, 78–85

disassembled code, 245

network, 961

unions, 308

bytes, 39, 70

copying, 169

range, 72

register operations, 217

Y86 encoding, 395–396

%bx [x86-64] low order 16 bits of register %rbx, 216

C language

    bit-level operations, 90–92

    floating-point representation, 160–162

    history, 71

    logical operations, 92–93

    origins, 40

    shift operations, 93–95

    static libraries, 720–724

C++ language, 713

    linker symbols, 716

    objects, 302–303

    software exceptions, 759–760, 822

.c source files, 707

C standard library, 40–41, 42

C11 standard, 71

C90 standard, 71

C99 standard, 71

fixed data sizes, 77

integral data types, 103

cache block offset (CO), 859

cache-friendly code, 669–675, 670  

cache lines  

  cache sets, 651  

  vs. sets and blocks, 670  

cache-oblivious algorithms, 685  

cache set index (CI), 859  

cache tags (CT), 859  

cached pages, 842  

  caches and cache memory, 646, 651  

  address translation, 859  

  anatomy, 667  

  associativity, 669  

  cache-friendly code, 669–675, 670  

  data, 556, 667, 667  

  direct-mapped. See direct-mapped  

  caches  

  DRAM, 842  

  fully associative, 663–664  

  hits, 648  

  importance, 47–50  

  instruction, 554, 667, 667  

  locality in, 641, 679–683, 846  

  managing, 649  

  memory mountains, 675–679  

  misses, 506, 648, 648–649  

  organization, 651–653  

  overview, 646–648  

  page allocation, 846  

  page faults, 844, 844–845  

  page hits, 844  

  page tables, 842–844, 843  

  performance, 569, 667–669, 675–683  

  practice problems, 664–666  

  proxy, 988  

  purpose, 616  

  set associative, 660, 660–662  

  size, 668  

  SRAM, 842  

  symbols, 653  

  virtual memory with, 841–847, 853  

  write issues, 666–667  

  write strategies, 669  

  Y86-64 pipelining, 505–506  

  call [x86-64] procedure call, 277–278  

  393  

  call [Y86-64] instruction, 440, 464  

  callee procedures, 287  

  callee-save registers, 287, 287–288  

  caller procedures, 287  

  caller-save registers, 287, 287–288  

  calling environments, 819  

  callback function [C Stdlib] memory  

  allocation  

  declaration, 170  

  dynamic memory allocation, 877

---

<!-- Page 1078 -->

security vulnerability, 136–137

callq [x86-64] procedure call, 277

calls, 53, 763–764

error handling, 773–774

Linux/x86-64 systems, 766–767

in performance, 548–549

canary values, 322–323

canceling mispredicted branch

handling, 480

carriage return (CR) characters, 928

carry flag condition code, 237, 342

CAS (column access strobe) requests,

619

case expressions in HCL, 414, 414

casting, 80

explicit, 111

floating-point values, 161

pointers, 314, 890

signed values, 106–107

catching signals, 794, 797, 799

cells

DRAM, 618, 619

SRAM, 617

central processing units (CPUs), 45, 45–46

Core i7. See Core i7 microproces-sors

early instruction sets, 397

effective cycle time, 638

embedded, 399

Intel. See Intel microprocessors

logic design. See logic design

many-core, 507

multi-core, 52, 60–61, 204, 641, 1008

overview, 388–390

pipelining. See pipelining

RAM, 420

sequential Y86 implementation.

See sequential implementation

implement

superse

Y86. See Y86-64 instruction set architecture

Cerf, Vinton, 967

CERT (Computer Emergency Response Team), 136

CF [x86-64] carry flag condition code,

237, 342

CGI (common gateway interface)

program, 989, 989–991



CGI adder function, 991

chains, proxy, 988

char [C] data types, 76, 97

character devices, 928

check_clients function, 1017, 1020

child processes, 776

creating, 777–779

default behavior, 780

error conditions, 781–782

exit status, 781

reaping, 779, 779–785

waitpid function, 782–785

CI (cache set index), 859

circuits

combinational, 410, 410–416

retiming, 457

sequential, 417

CISC (complex instruction set computers), 397, 397–399

%c1 [x86-64] low order 8 of register %rcx, 216

Clarke, Dave, 967

classes

data hazards, 471

exceptions, 762–764

instructions, 218

size, 899

storage, 1030–1031

clear bit in descriptor set macro, 1014

clear descriptor set macro, 1014

clear signal set instruction, 801

client-server model, 954, 954–955

clienterror [CS:APP] TINY helper function, 995–996

clients

client-server model, 954

telnet, 57

clock signals, 417

clocked registers, 437–438

clocking in logic design, 417–420

close [Unix] close file, 930, 930–931

close operations for files, 927, 930–931

close shared library function, 738

closedir functions, 941

cltq [x86-64] Sign extend %eax to %rax, 221

cmova [x86-64] move if unsigned greater, 253

cmovae [x86-64] move if unsigned greater or equal, 253

cmovb [x86-64] move if unsigned less,

253

cmovbe [x86-64] move if unsigned less

or equal, 253



cmove [Y86-64] move when equal, 393

cmovg [x86-64] move if greater, 253, 393

cmovge [x86-64] move if greater or equal, 253, 393

cmov1 [x86-64] move if less, 253, 393

cmov1e [x86-64] move if less or equal,

253, 393

cmovna [x86-64] move if not unsigned greater, 253

cmovnae [x86-64] move if unsigned greater or equal, 253

cmovnb [x86-64] move if not unsigned less, 253

cmovne [x86-64] move if not equal,

253,393

cmovng [x86-64] move if not greater, 253

cmovnge [x86-64] move if not greater or equal, 253

cmovnl [x86-64] move if not less, 253

cmovnle [x86-64] move if not less or equal, 253

cmovns [x86-64] move if nonnegative,

253

cmovnz [x86-64] move if not zero, 253

cmovp [x86-64] move if even parity, 360

cmovs [x86-64] move if negative, 253

cmovz [x86-64] move if zero, 253

CMP [instruction class] Compare, 238

cmpb [x86-64] compare byte, 238

cmp1 [x86-64] compare double word,

238

cmpq [x86-64] compare double word,

238

cmpw [x86-64] compare word, 238

cmtest script, 501

CO (cache block offset), 859

coalescing blocks, 896

with boundary tags, 887–890

free, 886

memory, 883

Cocke, John, 397

code

performance strategies, 597–598

profilers, 598–600

representing, 85–86

self-modifying, 471

Y86 instructions, 394, 395–396

code motion, 544

---

<!-- Page 1079 -->

Cohen, Danny, 79

old caches, 648

old misses, 648

Cold War, 967

collectors, garbage, 875, 902

basics, 902–903

conservative, 903, 905–906

Mark&Sweep, 903–906

column access strobe (CAS) requests 619

column-major sum function, 672

combinational circuits, 410, 410–416

combinational pipelines, 448–450, 496–498

common gateway interface (CGI) program, 989, 989–991

Compaq Computer Corp. RISC processors, 399

compare byte instruction, 238

compare double precision, 342

compare double word instruction, 238

compare instructions, 238

compare single precision, 342

compare word instruction, 238

comparison operations for floating-point code, 342–345

compilation phase, 41

compilation systems, 42, 42–43

compile time, 706

compile-time interpositioning, 744–745

compiler drivers, 40, 707–708

compilers, 42, 200

optimizing capabilities and limitations, 534–538

process, 205–206

purpose, 207

complement instruction, 228

complex instruction set computers (CISC), 397, 397–399

compulsory misses, 648

computation stages in pipelining, 457–458

computed goto, 269

Computer Emergency Response Team (CERT), 136

computer systems, 38

concurrency, 1008

ECF for, 759

flow synchronizing, 812–814

and parallelism, 60

run, 769

thread-level, 60–62

concurrent execution, 769

concurrent flow, 769, 769–770

concurrent processes, 51, 52

concurrent programming, 1008–1009

deadlocks, 1063–1066

with I/O multiplexing, 1014–1021

library functions in, 1060–1061

with processes, 1009–1013

races, 1061–1063

reentrancy issues, 1059–1060

shared variables, 1028–1031

summary, 1066

threads, 1021–1028

for parallelism, 1049–1054

safety issues, 1056–1058

concurrent programs, 1008

concurrent servers, 1008

based on prethreading, 1041–1049

based on processes, 1010–1011

based on threads, 1027–1028

condition code registers, 207

hazards, 471

SEQ timing, 437–438

condition codes, 237, 237–238

accessing, 238–241

x86-64, 237

Y86-64, 391–393

condition variables, 1046

conditional branches, 208, 245

assembly form, 247

condition codes, 237–238

condition control, 245–249

moves, 250–256, 586–589

switch, 268–274

conflict misses, 649, 658–660

connect [Unix] establish connection with server, 970, 970–971

connected descriptors, 972, 972–973

connections

EOF on, 984

Internet, 961, 965–967

I/O devices, 632–633

persistent, 988

conservative garbage collectors, 903, 905–906

constant words in Y86-64, 395

constants

floating-point code, 340–341

free lists, 892–893

maximum and minimum values, 104

multiplication, 137–139

for ranges, 103–104

Unix, 782

content

dynamic, 989–990

serving, 985

Web, 984, 985–986

context switches, 52, 772–773

contexts, 772

    processes, 52, 768

    thread, 1022, 1029

continue command, 316

Control Data Corporation 6600

    processor, 558

control dependencies in pipelining, 455, 465

control flow, 758

    exceptional. See exceptional control flow (ECF)

    logical, 768, 768–769

    machine-language procedures, 275

control hazards, 465

control logic blocks, 434, 434, 441, 46

control logic in pipelining, 491

    control mechanism combinations, 496–498

    control mechanisms, 495–496

    design testing and verifying, 501

    implementation, 498–500

    special cases, 491–493

    special conditions, 493–495

control structures, 236–237

    condition codes, 236–241

    conditional branches, 245–249

    conditional move instructions, 250–256

    jumps, 241–245

    loops. See loops

    switch statements, 268–274

control transfer, 277–281, 758

controllers

    disk, 631, 631–632

I/O devices, 45

    memory, 619, 620

conventional DRAMs, 618–620

conversions

    binary

        with hexadecimal, 72–73

        signed and unsigned, 106–112

        to two's complement, 100, 108–109, 133

        to unsigned, 98–99

    floating point, 161, 332–337

    lowercase, 545–547

    number systems, 72–75

    convert active socket to listening socket function, 971

    convert application-to-network function, 962

    convert double precision to integer instruction, 333

---

<!-- Page 1080 -->

convert double precision to quad-word

integer instruction. 333

convert double to single precision

instruction, 335

convert host and service names

function, 973, 973–976

convert host-to-network long function, 961

convert host-to-network short function, 961

convert integer to double precision

instruction, 333

convert network-to-application function, 962

convert network-to-host long function, 961

convert network-to-host short function, 961

convert packed single to packed double precision instruction, 334

convert quad-word integer to double

precision instruction, 333

convert quad-word integer to singl

precision instruction, 333

convert quad word to oct word instruction, 234

convert single precision to integer instruction, 333

convert single precision to quad-word integer instruction, 333

convert single to double precision

instruction, 334

convert socket address to host and

service names function, 976,

976–978

copy_elements function, 136

copy file descriptor function, 945

copy-on-write technique, 871, 871–872

copying

bytes in memory, 169

descriptor tables, 945

text files, 936

Core 2 microprocessors, 204, 624

Core i7 microprocessors, 61

abstract operation model, 561–567

address translation, 862–864

caches, 667

Haswell, 543

memory mountain, 677

Nehalem, 204

page table entries, 862–864

QuickPath interconnect, 624

virtual memory, 861–864



core memory, 793

cores in multi-core processors, 204, 641, 1008

correct signal handling, 806–810

counting semaphores, 1039

CPE (cycles per element) metric, 538, 540, 543–544

cpfile [CS:APP] text file copy, 936

CPI (cycles per instruction)

five-stage pipelines, 507

in performance analysis, 500-

CPUs. See central processing units (CPUs)

cqto [x86-64] convert quad word to oct word, 234, 235

CR (carriage return) characters, 928

CR3 register, 862

Cray 1 supercomputer, 389

create/change environment variable function, 788

create child process function, 776, 777–779

create thread function, 1024

critical path analysis, 534

critical paths, 561, 565

critical sections in progress graphs, 1036

CS:APP

header files, 782

wrapper functions, 774, 1077

csapp.c [CS:APP] CS:APP wrapper functions, 774, 1077

csapp.h [CS:APP] CS:APP header file, 774, 782, 1077

csh [Unix] Unix shell program, 789

CT (cache tags), 859

ctest script, 501

ctime function, 1060

ctime_ts [CS:APP] thread-safe non-reentrant wrapper for ctime, 1058

Ctrl+C key

nonlocal jumps, 821

signals, 794, 797, 831

Ctrl+Z key, 797, 831

current working directory, 928

cvtsd2ss [x86-64] convert double to single precision, 335

cvtss2sd [x86-64] convert single to double precision, 334

cycles per element (CPE) metric, 538, 540, 543–544

cycles per instruction (CPI)

five-stage pipelines, 507

in performance analysis, 500–504

cylinders

disk, 627

spare, 632

%cx [x86-64] low order 16 bits of

register %rcx, 216

d-caches (data caches), 556, 667

data

conditional transfers, 250–256

forwarding, 472–475, 473

sizes, 75–78

data alignment, 309, 309–312

data dependencies in pipelining, 455, 465–467

data-flow graphs, 561–566

data formats in machine-level programming, 213–215

data hazards, 465

avoiding, 477–480

classes, 471

forwarding for, 472–475

load/use, 475–477

stalling, 469–472

Y86-64 pipelining, 465–47

data memory in SEQ timing, 437

data movement instructions, 218–225

data references

locality, 642–643

PIC, 740–741

.data section, 710

data segments, 732

data structures, 301

data alignment, 309–312

structures, 301–305

unions, 305–309

data transfer, procedures, 281–284

data types. See types

database transactions, 955

datagrams, 960

DDD debugger with graphical user interface, 315

DDR SDRAM (double data-rate synchronous DRAM), 622

deadlocks, 1063, 1063–1066

deallocate heap storage function, 877

.debug section, 711

debugging, 315–316

DEC [instruction class] decrement, 22

decimal notation, 68

decimal system conversions, 73–75

declarations

arrays, 291–292, 299

pointers, 77

---

<!-- Page 1081 -->

public and private, 713

structures, 301–305

unions, 305–309

lecode stage

instruction processing, 421, 423–433

PIPE processor, 485–489

sequential processing, 436

Y86-64 implementation, 442–444

Y86-64 pipelining, 459

decoding instructions, 555

decrement instruction, 228, 230

deep copies, 1060

deep pipelining, 454–455

default actions with signal, 798

default behavior for child processes,

780

default function code, 440

deferred coalescing, 886

#define [C] preprocessor directive

delete command, 316

delete environment variable function,

788

DELETE method in HTTP, 987

delete signal from signal set instruction, 801

delivering signals, 794

delivery mechanisms for protocols,

958

demand paging, 846

demand-zero pages, 869

demanding process (C++ and Java), 716, 716

denormalized floating-point value,

150, 150–152

dependencies

control in pipelining systems, 455,

465

data in pipelining systems, 455,

465–467

reassociation transformations, 578

write/read, 593–595

ereferencing pointers, 84, 224, 293,

313, 906–907

lescriptor sets, 1013, 1014

descriptor tables, 943, 945

descriptors, 927

connected and listening, 972, 972–973

socket, 970

destination hosts, 958

detach thread function, 1026

detached threads, 1025

detaching threads, 1025–1026

%di [x86-64] low order 16 bits of

register %rdi, 216

diagrams

hardware, 434

pipeline, 449



Digital Equipment Corporation, 92

Dijkstra, Edsger, 1037–1038

%dil [x86-64] low order 8 of register %rdi, 216

DIMM (dual inline memory module), 620

direct jumps, 242

direct-mapped caches, 653

conflict misses, 658–660

example, 655–657

line matching, 654

line replacement, 655

set selection, 654

word selection, 655

direct memory access (DMA), 47, 634

directives, assembler, 212, 402

directories

description, 927, 927–928

reading contents, 941–942

directory streams, 941

dirty bits

in cache, 666

Core i7, 863

dirty pages, 863

disas command, 316

disassemblers, 80, 105, 209, 209–210

disks, 625

accessing, 633–636

anatomy, 636

backups, 647

capacity, 627, 627–628

connecting, 632–633

controllers, 631, 631–632

geometry, 626–627

logical blocks, 631–632

operation, 628–631

trends, 638

distributing software, 737

division

floating-point, 338

instructions, 234–236

Linux/x86-64 system errors, 765

by powers of 2, 139–143

divq [x86-64] unsigned divide, 234, 236

%d1 [x86-64] low order 8 of register %rdx, 216

d1close [Unix] close shared library,

738

derror [Unix] report shared library error, 738

DLL (dynamic link library), 735

dlsym [Unix] get address of shared

library symbol, 738



dlopen [Unix] open shared library, 737

DMA (direct memory access), 47, 634



DMA transfer, 634

DNS (domain name system), 964

do [C] variant of while loop, 256–259

do-while statement, 256

doit [CS:APP] TINY helper function, 992, 994, 994–995

dollar signs ($) for immediate

 operands, 217

domain names, 961, 963–965

domain name system (DNS), 964

dotprod [CS:APP] vector dot product, 658

dots (.) in dotted-decimal notation, 962

dotted-decimal notation, 962, 962

double [C] double-precision floating point, 160, 161

double [C] integer data type, 77

double data-rate synchronous DRAM (DDR SDRAM), 622

double floating-point declaration, 214

double-precision addition instruction,

338

double-precision division instruction,

338

double-precision maximum

instruction, 338

double-precision minimum

instruction, 338

double-precision multiplication instruction, 338

double-precision representation

C, 77, 160–162

IEEE, 149, 149

machine-level data, 214

double-precision square root instruction, 338

double-precision subtraction instruction, 338

double word to quad word instruction,

235

double words, 213

DRAM. See dynamic RAM (DRAM)

DRAM arrays, 618

DRAM cells, 618, 619

drivers, compiler, 40, 707–708

dual inline memory module (DIMM), 620

dup2 [Unix] copy file descriptor, 945

duplicate symbol names, 716–720

dynamic code, 326

dynamic content, 737, 989–990

dynamic link libraries (DLLs), 735

---

<!-- Page 1082 -->

dynamic linkers, 735

dynamic linking, 735, 735–737

dynamic memory allocation

allocated block placement, 885

allocator design, 890–892

allocator requirements and goals,

880–881

coalescing free blocks, 886–887

coalescing with boundary tags,

887–890

explicit free lists, 898–899

fragmentation, 882

heap memory requests, 886

implementation issues, 882–883

implicit free lists, 883–885

malloc and free functions, 876–879

overview, 875–876

purpose, 879–880

segregated free lists, 899–901

splitting free blocks, 885–886

dynamic memory allocators, 875–876

dynamic RAM (DRAM), 45

caches, 842, 844, 844–845

conventional, 618–620

enhanced, 621–622

historical popularity, 622

modules, 620, 621

vs. SRAM, 618

trends, 638–639

dynamic Web content, 985

%dx [x86-64] low order 16 bits of register %rdx, 216

E-way set associative caches, 660–661

%eax [x86-64] low order 32 bits of register %rax, 216

%ebp [x86-64] low order 32 bits of register %rbp, 216

%ebx [x86-64] low order 32 bits of register %rbx, 216

ECF. See exceptional control flow (ECF)

ECHILD return code, 782–783

echo [CS:APP] read and echo input lines, 983

echo function, 317–318, 323

echo_cnt [CS:APP] counting version of echo, 1048

echoclient.c [CS:APP] echo client,

980-981

echoserveri.c [CS:APP] iterative

echo server, 972–973, 983

echoservert.c [CS:APP] concurrent

echo server based on threads,

1027

echoservert_pre.c [CS:APP]

prethreaded concurrent echo

server, 1047



%ecx [x86-64] low order 32 bits of register %rcx, 216

%edi [x86-64] low order 32 bits of register %rdi, 216

EDO DRAM (extended data out

DRAM), 622

%edx [x86-64] low order 32 bits of register %rdx, 216

EEPROMs (electrically erasable programmable ROMs), 623

effective addresses, 217, 726

effective cycle time, 638

efficiency of parallel programs, 1055, 1055

EINTR return code, 782

electrically erasable programmable ROMs (EEPROMs), 623

ELF. See executable and linkable format (ELF)

EM64T processors, 204

embedded processors, 399

encapsulation, 958

encodings in machine-level programming, 205–206  

code examples, 208–211  

code overview, 206–207  

formatting, 211–213  

Y86-64 instructions, 394–3

end-of-file (EOF) condition, 927, 984

end of line (EOL) indicators, 928

entry points, 732, 733–734

environment variables lists, 787–788

EOL (end of line) indicators, 928

ephemeral ports, 966

epilogue blocks, 891

EPIPE error return code, 1000

erasable programmable ROMs

(EPROMs), 623

erno [Unix] Unix error variable,

1078

error-correcting codes for memory,

618

error handling

system calls, 773–774

Unix systems, 1078–1079

wrappers, 774, 1077, 1079–1

error-reporting functions, 773

errors

child processes, 781–782

link-time, 43

off-by-one, 908

race, 812, 812–814

reporting, 1079

synchronization, 1031

%esi [x86-64] low order 32 bits of register %rsi, 216

%esp [x86-64] low order 32 bits of stack pointer register %rsp, 21

establish connection with server functions, 970, 970–971, 978–9

establish listening socket function,

980, 980

etest script, 501

Ethernet segments, 956, 956

Ethernet technology, 956

EUs (execution units), 554, 556

eval [CS:APP] shell helper routine, 790, 791

event-driven programs, 1016

based on I/O multiplexing, 1016–

based on threads, 1049

events, 759

scheduling, 799

state machines, 1016

evicting blocks, 648

exabytes, 75

excepting instructions, 481

exception handlers, 760, 760

exception handling

in instruction processing, 421

Y86-64, 399–400, 480–483

exception numbers, 761

exception table base registers, 761

exception tables, 761, 761

exceptional control flow (ECF), 75

exceptions, 759–767

importance, 758–759

nonlocal jumps, 817–822

process control. See processes

signals. See signals

summary, 823

system call error handling, 773–7

exceptions, 759

anatomy, 759–760

asynchronous, 762

classes, 762–764

data alignment, 312

handling, 760–762

Linux/x86-64 systems, 765–767

status code for, 440

synchronous, 763

Y86, 392

exclamation points! for NOT

operation, 409

EXCLUSIVE-OR Boolean operation, 8

Y86-64, 392

---

<!-- Page 1083 -->

EXCLUSIVE-OR operation in execute stage, 444

exclusive-or packed double precision instruction, 341

exclusive-or packed single precision instruction, 341

executable and linkable format (F'709

executable object files, 731–732

header tables, 710, 732

headers, 710–711

relocation, 726

symbol tables, 711–715

executable code, 206

路线图

executable object programs, 40

execute access, 325

execute disable bit, 863

Institute stage

instruction processing, 421, 423–433

PIPE processor, 489–490

sequential processing, 436

sequential Y86-64 implementation,

444–445

Y86-64 pinelining, 459

Y86-64 pipelining, 459

execution

concurrent, 769

parallel, 770

speculative, 555, 555, 585–586

tracing, 423, 430–431, 439

execution units (EUs), 554, 556

xecve [Unix] load program, 78

arguments and environment variables, 786–788

child processes, 735, 737

loading programs, 733

running programs, 789–792

virtual memory, 872–873

exit [C Stdlib] terminate process, 775

exit status, 775, 781

expanding bit representation, 112–116

expansion slots, 633

explicit allocator requirements and goals, 880–881

explicit dynamic memory allocators,

875–876

explicit free lists, 898–899

explicit thread termination, 1024

explicit waiting for, signals, 814–817

explicitly reentrant functions, 1059

exploit code, 320

exponents in floating-point

representation, 148

extend_heap [CS:APP] allocator: extend heap, 894

extended data out DRAM (EDO

DRAM), 622

extended precision floating-point

representation, 173, 173

external exceptions in pipelining, 480

external fragmentation, 882, 882

fall through in switch statements, 269

false fragmentation, 886

fast page mode DRAM (FPM

DRAM), 621

fault exception class, 762

faulting instructions, 763

taults, /64

Linux/x86-64 systems, 765, 868–869

Y86-64 pipelining caches, 506

FD_CLR [Unix] clear bit in descriptor set, 1013, 1014

FD_ISSET [Unix] bit turned on in descriptor set, 1013, 1014, 1016

FD_SET [Unix] set bit in descriptor set,

1013, 1014

FD_ZERO [Unix] clear descriptor set, 1013, 1014

feedback in pipelining, 455–457, 461

feedback paths, 432, 455

fetch file metadata function, 939

fetch stage

instruction processing, 420, 423–433

PIPE processor, 483–485

SEQ, 440–442

sequential processing, 436

Y86-64 pipelining, 459

fetches, locality, 643–644

fgets function, 318

Fibonacci (Pisano), 68

field-programmable gate arrays (FPGAs), 503

FIFOs, 1013

file descriptors, 927

file position, 927

file tables, 772, 942

FILE type, 947

filenames, 927

files, 55

as abstraction, 63

anonymous, 869

binary, 39

metadata, 939–940

object. See object files

register, 46, 207, 394–395, 418–419, 437, 557

regular, 869

sharing, 942–944

system-level I/O. See system-level I/O

types, 927–929

Unix, 926, 926–927



FINGER command, 320

fingered daemon, 320

finish command, 316

firmware, 623

first-fit block placement policy, 885, 885

first-level domain names, 963

first readers-writers problem, 1044

fits, segregated, 899, 900–901

five-stage pipelines, 507

fixed-size arithmetic, 121

fixed-size arrays, 296–298

fixed-size integer types, 77, 103

flash memory, 623

flash translation layers, 636–637

float [C] single-precision floating point, 160

float floating-point declaration, 214

floating-point code

architecture, 329, 329–332

arithmetic operations, 338–340

bitwise operations, 341–342

comparison operations, 342–345

constants, 340–341

movement and conversion operations, 332–337

observations, 345

in procedures, 337–338

floating-point representation and programs, 144–145

arithmetic, 69

C, 160–162

denormalized values, 150, 150–152

encodings, 68

extended precision, 173, 173

fractional binary numbers, 145–148

IEEE, 148–150

normalized value, 149–150

operations, 158–160

overflow, 163

pi, 176

rounding, 156, 156–158

special values, 151

support, 76

x87 processors, 203

flows

concurrent, 769, 769–770

Flows

concurrent, 769, 769–770

control, 758

logical, 768, 768–769

parallel, 770

synchronizing, 812–814

---

<!-- Page 1084 -->

flushed instructions, 558

FNONE [Y86-64] default function code, 440

for [C] general loop statement,

264–268

guarded-do translation, 261

jump-to-middle translation, 25

forbidden regions, 1039

foreground processes, 789

fork [Unix] create child process, child processes, 737

example, 777–779

running programs, 789–792

virtual memory, 872

fork.c [CS:APP] fork example, 777

formal verification in pipelining, 502

format strings, 83

formats for machine-level data,

213–215

formatted disk capacity, 632

formatted printing, 83

formatting

disks, 632

machine-level code, 211–213

forwarding

for data hazards, 472–475

load, 513

forwarding priority, 487–488

FPGAs (field-programmable gate arrays), 503

FPM DRAM (fast page mode

DRAM), 621

fprintf [C Stdlib] function, 83

fractional binary numbers, 145–148

fractional floating-point representation, 148–156, 173

fragmentation, 882

dynamic memory allocation, 882

false, 886

frame pointers, 326

frames

Ethernet, 956

stack, 276, 276–277, 312, 326–329

free blocks, 875

coalescing, 886–887

splitting, 885–886

free bounded buffer function, 1043

free [C Stdlib] deallocate heap storage, 877, 877–879

interpositioning libraries, 744

wrappers for, 747

free heap block function, 896

free heap blocks, referencing data in,

910–911

free lists

creating, 893–895

dynamic memory allocation, 883–885

explicit, 898–899

implicit, 884

manipulating, 892–893

segregated, 899–901

free software, 42

free up getaddrinfo resources function,

973

freeaddrinfo [Unix] free up getaddrinfo resources, 973, 974

FreeBSD open-source operating system, 122–123

freeing blocks, 896

Freescale

processor family, 388

RISC design, 397

front side bus (FSB), 624

fstat [Unix] fetch file metadata, 939

full duplex connections, 965

full duplex streams, 948

fully associative caches, 662

line matching and word selection, 663–664

set selection, 663

fully linked executable object files, 732

function calls

performance strategies, 597

PIC, 741–743

function part in Y86-64 instruction

specifier, 394

functional units, 556–557, 559–560

functions

pointers to, 314

reentrant, 802, 1059

static libraries, 720–724

system-level, 766

thread-safe and thread-unsafe

1056, 1056–1058

wrapper, 747

in Y86 instructions, 395

gai_error [CS:APP] reports GAI-style errors, 1079

gai_strerror [Unix] print getaddrinfo error message, 974

GAI-style error handling, 1078, 1078–1079

gaps between disk sectors, 626,

garbage, 902

garbage collection, 876, 902

garbage collectors, 876, 902

basics, 902–903

conservative, 903, 905–906

Mark&Sweep, 903–906

overview, 901–902

gates, logic, 409

GCC (GNU compiler collection compiler

code formatting, 211–212

inline assembly, 214

options, 71

working with, 204–205

GDB GNU debugger, 209, 315, 315–316

general-purpose registers, 215, 215–216

geometry of disks, 626–627

get address of shared library symbol function, 738

“get from” operator (C++), 926

GET method in HTTP, 987

get parent process ID function, 775

get process group ID function, 795

get process ID function, 775

get thread ID function, 1024

getaddrinfo [Unix] convert host and

service names, 973, 973–976

getenv [C Stdlib] read environment variable, 787

gethostbyaddr [Unix] get DNS host entry, 1060

gethostbyname [Unix] get DNS host entry, 1060

getnameinfo [Unix] convert socket address to host and service names, 976, 976–978

getpeername function [C Stdlib]

security vulnerability, 122–123

getpgrp [Unix] get process group ID 795

getpid [Unix] get process ID, 775

getppid [Unix] get parent process

ID, 775

getrusage [Unix] function, 847

gets function, 315, 317–318

GHz (gigahertz), 538

giga-instructions per second (GIPS), 449

gigabytes, 628

gigahertz (GHz), 538

GIPS (giga-instructions per second), 449

global IP Internet. See Internet

Global Offset Table (GOT), 741, 741–743

global symbols, 711

global variable mapping, 1030–1031

---

<!-- Page 1085 -->

GNO compiler collection. See GCC (GNU compiler collection) compiler

GNU project, 42

GOT (global offset table), 741, 741–743

goto [C] control transfer statement, 246, 269

goto code, 246

GPROF Unix profiler, 598, 598–599

gradual underflow, 151

granularity of concurrency, 1021

graphic user interfaces for debuggers,

315

graphics adapters, 632

graphs

data-flow, 561–566

process, 777, 778

progress. See progress graphs reachability, 902

greater than signs >

deferencing operation, 302

“get from” operator, 926

right hoinkies, 945

groups

abelian, 125

process, 795

guard values, 322

guarded-do translation, 261

.h header files, 722

half-precision floating-point representation, 173, 173

halt [Y86-64] halt instruction execution, 393

code for, 440–441

exceptions, 400, 480–483

in pipelining, 498

handlers

exception, 760, 760

interrupt, 762

signal, 794, 799

handling signals

blocking and unblocking, 800–801

portable, 810–811

hardware caches. See caches and cache

memory

hardware control language (HCL),

408

Boolean expressions, 410–411

integer expressions, 412–416

logic gates, 409

hardware description languages (HDLs), 409, 503

hardware exceptions, 760

hardware interrupts, 762

hardware management, 50–51

hardware organization, 44

buses, 44

I/O devices, 45

main memory, 45

processors, 45–46

hardware registers, 417–420

hardware structure for Y86-64, 432–436

hardware units, 432–434, 437

hash tables, 603–604

Haswell microarchitecture, 861

Haswell microprocessors, 204, 251, 330, 543, 557, 559

hazards in pipelining, 390, 4

avoiding, 477–480

classes, 471

forwarding for, 472–475

load/use, 475–477

overview, 465–469

stalling for, 469–472

HCL (hardware control language), 408

Boolean expressions, 410–411

integer expressions, 412–416

logic gates, 409

HDLs (hardware description languages), 409, 503

head crashes, 629

HEAD method in HTTP, 987

header files

static libraries, 723

system, 782

header tables in ELF, 710, 732

headers

blocks, 883

Ethernet, 956

request, 987

response, 988

heap, 54, 54–55, 875

dynamic memory allocation, 875–876

Linux systems, 733

referencing data in, 910–911

requests, 886

hello [CS:APP] C hello program, 38, 46–48

help command, 316

helper functions, sockets interface, 978–980

Hennessy, John, 397, 507

heterogeneous data structures, 301

data alignment, 309–312

structures, 301–305

unions, 305–309

hexadecimal (hex) notation, 72, 72–75

hierarchies

domain name, 963

storage devices, 50, 50, 645–650



high-level design performance

strategies, 597

hit rates, 667

hit time, 667

hits

cache, 648, 667

write, 666

hlt [x86-64] halt instruction execution, 393

HLT [Y86-64] status code indicating halt instruction, 400

hoinkies, 945, 946

holding mutexes, 1039

Horner, William, 566

Horner's method, 566

host bus adapters, 633

host bus interfaces, 633

host entries, 964

host information program command,

962

HOSTNAME command, 962

hosts

client-server model, 955

network, 958

number of, 966

sockets interface, 973–978

htest script, 501

HTML (hypertext markup language), 984, 984–985

hton1 [Unix] convert host-to-network long, 961

htons [Unix] convert host-to-network short, 961

HTTP. See hypertext transfer protocol (HTTP)

hubs, 956

hyperlinks, 984

hypertext markup language (HTML), 984, 984–985

hypertext transfer protocol (HTTP)

984

dynamic content, 989–990

methods, 987–988

requests, 987, 987–988

responses, 988, 988–989

transactions, 986–987

hyperthreading, 60, 204

HyperTransport interconnect, 624

i-caches (instruction caches), 554, 667

.i source files, 707

i386 microprocessor, 203

i486 microprocessor, 203

---

<!-- Page 1086 -->

1A32 (Intel Architecture 32-bit)

microprocessors, 81, 204

machine language, 201–202

registers, 215–216

iaddq [Y86-64] immediate add, 405

IBM

Freescale microprocessors, 388, 397

out-of-order processing, 558

RISC design, 397–399

ICALL [Y86-64] instruction code for call instruction, 440

ICANN (Internet Corporation for

Assigned Names and Numbers),

963

icode (instruction code), 420, 441

ICUs (instruction control units), 554

identifiers, register, 394

idiv1 [x86-64] signed divide, 235

idivq [x86-64] signed divide, 234

IDs (identifiers)

processes, 775–776

register, 394–395

IEEE. See Institute for Electrical and Electronics Engineers (IEEE)

if [C] conditional statement, 247–249

ifun (instruction function), 420, 441

IHALT [Y86-64] instruction code for

halt instruction, 440

TIRMOVQ [Y86-64] instruction code for

irmovq instruction, 440

ijk matrix multiplication, 680–682, 681

I JXX [Y86-64] instruction code for jump instructions, 440

ikj matrix multiplication, 680–682, 681

imem_error signal, 441

immediate add instruction, 405

immediate coalescing, 886

immediate offset, 217

immediate operands, 217

immediate to register move

instruction, 392

implicit dynamic memory allocators,

876

implicit free lists, 883–885, 884

implicit thread termination, 1024

implicitly reentrant functions, 1059

implied leading 1 representation, 150

IMRMOVQ [Y86-64] instruction code for mrmovq instruction, 440

IMUL [instruction class] multiply, 228

imulq [x86-64] signed multiply, 234,

234

in [HCL] set membership test, 417

in_addr [Unix] IP address structure,

961

INC [instruction class] increment, 228



include files, 722

#include [C] preprocessor directive,

206

incq instruction, 230

increment instruction, 228, 230

indefinite integer values, 161

index.html file, 986

index registers, 217

indexes for direct-mapped caches,

658–660

indirect jumps, 242, 270

inefficiencies in loops, 544–548

inet_ntoa [Unix] convert network-to-application, 1060

inet_ntop [Unix] convert network-to-application, 962

inet_pton [Unix] convert application-to-network, 962

infinity

constants, 160

representation

info frame command, 316

info registers command, 316

information, 38–40

information access with x86-64

registers, 215–216

data movement, 218–225

operand specifiers, 216–218

information storage, 70

addressing and byte ordering, 78–85

bit-level operations, 90–92

Boolean algebra, 86–89

code, 85–86

data sizes, 75–78

disks. See disks

floating point. See floating-point representation and programs

hexadecimal, 72–75

integers. See integers

locality. See locality

logical operations, 92–93

memory. See memory

segregated, 899

shift operations, 93–95

strings, 85

summary, 684

init function, 779

init_pool function, 1017, 1019

initial state in progress graphs, 1035

initialize nonlocal handler jump function, 819

initialize nonlocal jump functions, 819

initialize read buffer function, 934, 936

initialize semaphore function, 1038

initialize thread function, 1026



initializing threads, 1026

inline assembly, 214

inline substitution, 537

inlining, 537

INOP [Y86-64] instruction code for

nop instruction, 440

input events, 1016

input/output. See I/O (input/output)

insert item in bounded buffer function

1043

install portable handler function, 811

installing signal handlers, 799

Institute for Electrical and Electronic

Engineers (IEEE)

description, 145

floating-point representation and

programs, 148–150

denormalized, 150

normalized, 149–150

special values, 151

Standard 754, 145

standards, 145

Posix standards, 52

instr_valid signal, 441–442

instruction caches (i-caches), 554, 667

instruction code (icode), 420, 441

instruction control units (ICUs), 5

instruction function (ifun), 420, 441

instruction-level parallelism, 62, 533, 554, 598

instruction memory in SEQ timing,

437

instruction set architectures (ISAs), 46, 63, 206, 388

instruction set simulators, 402

instructions

classes, 218

decoding, 554

excepting, 481

fetch locality, 643–644

issuing, 463–464

jump, 46, 241–245

load, 46

low-level. See machine-level programming

move, 250–256, 586–589

operate, 46

pipelining, 504–505, 585

privileged, 771

store, 46

update, 45–46

Y86-64. See Y86-64 instruction set architecture

instructions per cycle (IPC), 507

int [C] integer data type, 76

---

<!-- Page 1087 -->

int [HCL] integer signal, 412

int data types, integral, 97

INT_MAX constant, maximum signed integer, 104

INT_MIN constant, minimum signed integer, 104

int32_t [Unix] fixed-size, 77

integer arithmetic, 120, 228

division by powers of 2, 139–143

multiplication by constants, 137–139

overview, 143–144

two’s complement addition, 126–13

two’s complement multiplication, 133–137

two’s complement negation, 131

unsigned addition, 120–126

integer bits in floating-point

integer bits in floating-point

representation, 173

nteger expressions in HCL, 412–416

nteger indefinite values, 161

nteger operation instruction, 440

nteger registers in x86-64, 215–216

arithmetic operations. See integer arithmetic

bit-level operations, 90–92

bit representation expansion, 112–116

byte order, 79–80

data types, 96–98

shift operations, 93–95

signed and unsigned conversions,

106–112

signed vs. unsigned guidelines, 119–120

truncating, 117–118

two's complement representation,

100–106

unsigned encoding, 98–100

integral data types, 96, 96–98

integration of caches and VM, 853

ntel assembly-code format, 213, 330, 347

ntel Corporation, 201

intel microprocessors

8086, 62, 203

80286, 203

Core 2, 204, 624

Core i7. See Core i7 microproces-

sors

data alignment, 312

evolution, 203–204

floating-point representation, 173

Haswell, 204, 251, 330, 559

i386, 203

486, 203

northbridge and southbridge

chipsets, 624

out-of-order processing, 558

Pentium, 203

Pentium II, 203

Pentium III, 203–204

Pentium 4, 204

Pentium 4E, 204

PentiumPro, 203, 558

Sandy Bridge, 204

x86-64. See x86-64 microprocessors

Y86-64. See Y86-64 instruction set architecture

interconnected networks (internets), 957–958

interfaces

bus, 624

host bus, 633

interlocks, load, 477

internal exceptions in pipelining, 480

internal fragmentation, 882

internal read function, 937

Internet, 957

connections, 965–967

domain names, 963–965

IP addresses, 961–963

organization, 960–961

origins, 967

internet addresses, 958

Internet Corporation for Assigned

Names and Numbers (ICANN),

963

Internet domain names, 961

Internet Domain Survey, 966

Internet hosts, number of, 966

Internet Protocol (IP), 960

Internet Software Consortium, 966

Internet worms, 320

internets (interconnected networks), 957, 957–958

interpositioning libraries, 743, 743–744

compile-time, 744–745

link-time, 744, 746

run-time, 746–748

interpretation of bit patterns, 68

interprocess communication (IPC), 1013

interrupt handlers, 762

interrupts, 762, 762–763

interval counting schemes, 600

INTN_MAX [C] maximum value of N-bit signed data type, 103

INTN_MIN [C] minimum value of N-bit signed data type, 103



int N_t [C] N-bit signed integer data type, 103

<inttypes.h> fixed-size integer

types, 234

invalid address status code, 400

invariants, semaphore, 1038

I/O (input/output), 45, 926

memory-mapped, 634

ports, 634

redirection, 945, 945–946

system-level. See system-level I/O

Unix, 55, 926, 926–927

I/O bridges, 623

I/O buses, 624, 632, 634

I/O devices, 45

addressing, 634

connecting, 632–633

I/O multiplexing, 1009

concurrent programming with, 1014–1021

event-driven servers based on, 1016–1021

pros and cons, 1021

IOPL [Y86-64] instruction code for integer operation instruction, 440

IP (Internet Protocol), 960

IP address structure, 961, 962

IP addresses, 960, 961–963

IPC (instructions per cycle), 507

IPC (interprocess communication), 1013

iPhone 5S, 389

IPOPQ [Y86-64] instruction code for popq instruction, 440

IPUSHQ [Y86-64] instruction code for pushq instruction, 440

IPv6, 961

IRET [Y86-64] instruction code for ret instruction, 440

IRMMOVQ [Y86-64] instruction code for rmmovq instruction, 440

irmovq [Y86-64] immediate to register move, 392, 440

IRRMOVQ [Y86-64] instruction code for rrmovq instruction, 440

ISAs (instruction set architectures), 46, 63, 206, 388

ISO (International Standards Organization), 40, 71

ISO C11 C standard, 71

ISO C90 C standard, 71

ISO C99 C standard, 71, 77, 360 integral data types, 103

---

<!-- Page 1088 -->

static libraries, 720–724

isPtr function, 905

issue time for arithmetic operations,

559

issuing instructions, 463–464

iterative servers, 982

iterative sorting routines, 603

ja [x86-64] jump if unsigned greater, 242

jae [x86-64] jump if unsigned greater or equal, 242

Java language, 713

byte code, 346

linker symbols, 716

numeric ranges, 104

objects, 302–303

software exceptions, 759–760, 822

threads, 1066

Java monitors, 1046

Java Native Interface (JNI), 740

jb [x86-64] jump if unsigned less, 242

jbe [x86-64] jump if unsigned less or equal, 242

je [Y86-64] jump when equal, 393, 430

jg [x86-64] jump if greater, 242, 393

jge [x86-64] jump if greater or equal, 242, 393

jik matrix multiplication, 680–682, 681

jki matrix multiplication, 680–682, 681

j1 [x86-64] jump if less, 242, 393

j1e [x86-64] jump if less or equal, 242, 393

jmp [x86-64] jump unconditionally, 242, 393

jna [x86-64] jump if not unsigned greater, 242

jnae [x86-64] jump if unsigned greater or equal, 242

jnb [x86-64] jump if not unsigned less, 242

jnbe [x86-64] jump if not unsigned less or equal, 242

jne [x86-64] jump if not equal, 242, 393

jng [x86-64] jump if not greater, 242

jinge [x86-64] jump if not greater or equal, 242

JNI (Java Native Interface), 740

jnl [x86-64] jump if not less, 242

jnle [x86-64] jump if not less or equal,

242

jns [x86-64] jump if nonnegative, 242

jnz [x86-64] jump if not zero, 242

jobs, 796

joinable threads, 1025

jp [x86-64] jump when parity flag set, 342

js [x86-64] jump if negative, 242

jtest script, 501

jump if greater instruction, 242, 393

jump if greater or equal instruction,

242,393

jump if less instruction, 242, 393

jump if less or equal instruction, 242, 393

jump if negative instruction, 242

jump if nonnegative instruction, 242

jump if not greater instruction, 242

jump if not greater or equal instruction, 242

jump if not less instruction, 242

jump if not less or equal instruction,

242

jump if not unsigned greater instruction, 242

jump if not unsigned less instruction,

242

jump if not unsigned less or equal instruction, 242

jump if not zero instruction, 242

jump if unsigned greater instruction,

242

jump if unsigned greater or equal instruction, 242

jump if unsigned less instruction, 242

jump if unsigned less or equal instruction, 242

jump if zero instruction, 242

jump instructions, 46, 241–245,

direct, 242

indirect, 242, 270

instruction code for, 440

nonlocal, 759, 817, 817–822

targets, 242

jump tables, 269, 270–271, 761

jump-to-middle translation, 259

jump unconditionally instruction, 242, 242

jump when equal instruction, 393

jump when parity flag set instruction,

342

just-in-time compilation, 326, 346

jz [x86-64] jump if zero, 242

 $ k \times 1 \text{ loop unrolling, } 567 $

 $ k \times 1a \text{ loop unrolling, } 580 $

 $ k \times k \text{ loop unrolling, } 575-576 $

K&R (C book), 40

Kahan, William, 145

Kahn, Robert, 967

kernel mode

exception handlers, 762

processes, 770–772, 771

system calls, 764

kernels, 53, 55, 734

exception numbers, 761

virtual memory, 866–867

Kernighan, Brian, 38, 40, 52, 71, 314

Kerrisk, Michael, 950

keyboard, signals from, 796–797

kij matrix multiplication, 680–682, 68

kill [Unix] send signal, 797

kill.c [CS:APP] kill example, 797

kji matrix multiplication, 680–682, 68

Knuth, Donald, 885, 887

ksh [Unix] Unix shell program, 789

1 suffix, 215

L1 cache, 49, 651

L2 cache, 49, 651

L3 cache, 651

labels for jump instructions, 241

LANs (local area networks), 956, 956–958

last-in, first out discipline, 225

last-in first-out (LIFO) free list order

899

latency

arithmetic operations, 559, 560

disks, 630

instruction, 449

load operations, 590–591

pipelining, 448

latency bounds, 554, 560

lazy binding, 742

LD Unix static linker, 708

LD-LINUX.so linker, 735

LD_PRELOAD environment variable,

746-748

LDD tool, 749

LEA instruction, 138

leaf procedures, 277

leaks, memory, 911, 1028

leaq [x86-64] load effective address: 227, 227–228, 313

least-frequently-used (LFU) replacement policies, 662

least-recently-used (LRU) replacement policies, 648, 662

least squares fit, 538, 540

leave [x86-64] prepare stack for return instruction, 328

left hoinkies (<), 946

length of strings, 119

---

<!-- Page 1089 -->

less than signs <

left hoinkies, 945

“put to” operator.

levels

optimization, 534

storage, 645–646

LF (line feed) characters, 928

LFU (least-frequently-used) replacement policies, 662

11bc library, 947

__libc_start_main, 734

libraries

in concurrent programming, 1060–1061

header files, 119

interpositioning, 743, 743–748

shared, 55, 735, 735–737

standard I/O, 947

static, 720, 720–724

LIFO (last-in first-out) free list order,

899

limits.h> file for numeric limit

declarations, 103–104, 113

ine feed (LF) characters, 928

ine matching

direct-mapped caches, 654

fully associative caches, 662

set associative caches, 661–6

line replacement

direct-mapped caches, 655

set associative caches, 662

.line section, 711

linear address spaces, 840

link-time errors, 43

link-time interpositioning, 744, 746

linkers and linking, 41, 200, 206

compiler drivers, 707–708

dynamic, 735, 735–737

library interpositioning, 743, 743–748

object files, 709, 709–710

executable, 731–734

loading, 733–734

relocatable, 710–711

tools for, 749

overview, 706–707

position-independent code, 740–743

relocation, 725–731

shared libraries from applications,

737–739

static, 708

summary, 749–750

symbol resolution, 715–725

symbol tables, 711–715

virtual memory for, 847–848

linking phase, 42

links in directories, 927

Linux operating system, 56, 81

code segments, 733–734

dynamic linker interfaces, 738

and ELF, 709

exceptions, 765–767

files, 927–929

signals, 792

static libraries, 721–722

virtual memory, 866–869

Lisp language, 121

listen [Unix] convert active socket to listening socket, 971

listening descriptors, 972–973

listening sockets, 971

little-endian ordering convention, 78, 78–80

load effective address instruction,

227–229, 313

load forwarding in PIPE, 513

load instructions, 46

load interlocks, 477

load operations

example, 624

process, 555–556

load penalty in CPI, 503

load performance of memory, 590–591

load program function, 786

load-store architecture in CISC vs. RISC, 398

load time for code, 706

load/use data hazards, 475, 475–477

loaders, 708, 733

loading

concepts, 735

executable object files, 733–734

process, 733

programs, 786–788

shared libraries from applications,

737–739

virtual memory for, 848

local area networks (LANs), 956,

local area networks (LANs), 956, 956–958

local automatic variables, 1030

local registers, 563

local static variables, 1030, 1030–1031

local storage

registers, 287–289

stack, 284–287

local symbols, 712

locality, 49, 616, 640–641

blocking for, 683

caches, 679–683, 846

exploiting, 683

forms, 640, 650

instruction fetches, 643–644

program data references, 642–643

summary, 644–645

localtime function, 1060

lock-and-copy technique, 1058, 1058

locking mutexes

lock ordering rule, 1065

for semaphores, 1039

logic design, 408

combinational circuits, 410–416, 449

logic gates, 409, 409

memory and clocking, 417–420

set membership, 416–417

logic gates, 409

logic synthesis, 391, 409, 503

logical blocks

disks, 631, 631–632

SSDs, 637

logical control flow, 768, 768–769

logical operations, 92–93, 227

discussion, 232–233

load effective address, 227–229

shift, 94, 140, 228, 230–232

special, 233–236

unary and binary, 230

long [C] integer data type, 76–77, 97–98

long double [C] extended-precision floating point, 161, 173

long double floating-point declaration, 214

long words in machine-level data, 215

longjmp [C Stdlib] nonlocal jump,

759,819,819

loop registers, 563

loop unrolling, 538, 540, 567

Core i7, 608

 $ k \times 1,567 $

 $ k \times 1a,580 $

 $ k \times k,575-576 $

overview, 567–571

with reassociation transformation

577–579

loopback addresses, 964

loops, 256

do-while, 256–259

for, 264–268

inefficiencies, 544–548

reverse engineering, 258

segments, 562–563

for spatial locality, 679–68

while, 259–264

low-level instructions. See machine-level programming

low-level optimizations, 598

---

<!-- Page 1090 -->

lowercase conversions, 545–547

LRU (least-recently-used) replacement policies, 648, 662

ls command, 928

1seek [Unix] function, 932–933

lvalue (C) assignable value for pointers, 313

Mac OS X (Apple Macintosh)

operating system, 63

machine checks, 765

machine code, 200

machine-level programm

arithmetic. See arithme

arrays. See arrays

buffer overflow. See buffe

control. See control structures

data-flow graphs from, 561–565

data formats, 213–215

data movement instructions, 2

225

encodings, 205–213

floating point. See floating-p code

GDB debugger, 315–316

heterogeneous data structur

heterogeneous data struct

historical perspective, 202–205

information access, 215–216

instructions, 40

operand specifiers, 216–218

overview, 200–202

pointer principles, 314

pre

ures

macros for storage allocators, 892–893

main memory, 45

accessing, 623–625

memory modules, 620

main threads, 1022

balloc [C Stdlib] allocate heap storage, 71, 360, 733, 875–876, 876

alignment with, 312

declaration, 170–171

dynamic memory allocation, 876–879

interpositioning libraries, 744

wrappers for, 747

man asci command, 84

mandatory alignment, 312

mangling process (C++ and Java), 716

many-core processors, 507

map disk object into memory function,

873

mapping

memory. See memory mapping

variables, 1030–1031



mark phase in Mark&Sweep, 903

Mark&Sweep algorithm, 902

Mark&Sweep garbage collectors, 903, 903–906

masking operations, 91

matrices

adjacency, 696

multiplying, 679–683

maximum floating-point instructions,

338

maximum two's complement number,

102

McIlroy, Doug, 52

maximum unsigned number function,

99

media instructions, 330

maximum values, constants for, 104

mem_init [CS:APP] heap model, 891

mem_sbrk [CS:APP] sbrk emulator,

891

membership, set, 416–417

memcpy [Unix] copy bytes from one region of memory to another, 169

memory, 616

accessing, 623–625

aliasing, 535, 536

associative, 661

caches. See caches and cache memory

copying bytes in, 169

data alignment in, 309–312

data hazards, 471

design, 420

dynamic. See dynamic memory allocation

hazards, 471

hierarchy, 50, 50, 645–650

leaks, 911, 1028

load performance, 590–591

in logic design, 397–400

machine-language procedures, 2

machine-level programming, 206

main, 45, 620, 623–625

mapping. See memory mapping

nonvolatile, 623

performance, 589–597

pipelining, 505–506

protecting, 325, 848–849

RAM. See random access memory (RAM)

ROM, 623

memory buses, 623

memory controllers, 619, 620

memory management units (MMUs 840, 843

memory-mapped I/O, 634

memory mapping, 848

areas, 869, 869

execve function, 872–873

fork function, 872

in loading, 735

objects, 869–872

user-level, 873–875

memory mountains, 675

Core i7 microprocessors, 677

overview, 675–679

memory references

operands, 217

out of bounds. See buffer overflow

in performance, 550–553

memory stage

instruction processing, 421, 423–43.

PIPE processor, 490–491

sequential processing, 436

sequential Y86-64 implementation, 445–447

Y86-64 pipelining, 459

memory system, 616

memory utilization, 881, 881

memset function, declaration, 170–171

metadata, 939, 939–940

metastable states, 617

methods

hypertext transfer protocol, 987–988

objects, 303

micro-operations, 555

microarchitecture, 46, 553

microprocessors. See central processing units (CPUs)

Microsoft Windows operating system, 81

MIME (multipurpose internet mail extensions) types, 985

minimum floating-point instructions, 338

minimum block size, 884

minimum two's complement number,

102

minimum values

constants, 104

two’s complement representation,

102

---

<!-- Page 1091 -->

handling, 479–480

performance penalties, 503, 556, 585–589

miss rates, 667

nisses, caches, 506, 648

kinds, 648–649

penalties, 668, 842

rates, 667

mkdir command, 928

mm_coalesce [CS:APP] allocator: boundary tag coalescing, 896

mm_free [CS:APP] allocator: free heap block, 896

mm-ijk [CS:APP] matrix multiply ijk, 681

mm-ikj [CS:APP] matrix multiply ikj,

681

mm_init [CS:APP] allocator: initialize heap, 894

mm-jik [CS:APP] matrix multiply jik,

681

mm-jki [CS:APP] matrix multiply jki,

681

mm-kij [CS:APP] matrix multiply kij, 681

mm-kji [CS:APP] matrix multiply kji,

681

mm_malloc [CS:APP] allocator: allocate heap block, 896, 897

mmap [Unix] map disk object into

memory, 873, 873–875

MMUs (memory management units), 840, 843

MMX media instructions, 203, 330

Mockapetris, Paul, 967

mode bits, 771

modern processor performance,

554–567

modes

kernel, 762, 764

processes, 770–772, 771

user, 762, 764

modified sequential processor implementation, 457–458

modular arithmetic, 121–122, 125

modules

DRAM, 620, 621

object, 709

monitors, Java, 1046

nonotonicity assumption, 882

nonotonicity property, 160

Moore, Gordon, 205

Moore's Law, 205, 205

OSAIC browser, 985

otherboards, 45

Motorola RISC processors, 399

MOV [instruction class] move data, 218, 218–219

movabsq [x86-64] move absolute quad word, 219, 219

movb [x86-64] move byte, 219

move absolute quad word instruction,

219, 219

move aligned, packed double

precision instruction, 332

move aligned, packed single precision instruction, 332

move and sign-extend instruction, 220, 221

move byte instruction, 219

move data instructions, 218–225

move double precision instruction,

332

move double word instruction, 219

move if even parity instruction, 360

move if greater instruction, 253, 393

move if greater or equal instruction,

253,393

move if less instruction, 253, 393

move if less or equal instruction, 253, 393

move if negative instruction, 253

move if nonnegative instruction, 253

move if not equal instruction, 253, 393

move if not greater instruction, 253

move if not greater or equal instruction, 253

move if not less instruction, 253

move if not less or equal instruction,

253

move if not unsigned greater instruction, 253

move if not unsigned less instruction,

253

move if not unsigned less or equal instruction, 253

move if not zero instruction, 253

move if unsigned greater instruction,

253

move if unsigned greater or equal instruction, 253

move if unsigned less instruction, 253

move if unsigned less or equal instruction, 253

move if zero instruction, 253

move instructions, conditional, 250–256, 586–589

move quad word instruction, 219

move sign-extended byte to double word instruction, 221

move sign-extended byte to qua word instruction, 221



move sign-extended byte to word instruction, 221

move sign-extended double word to

quad word instruction, 221

move sign-extended word to double word instruction, 221

move sign-extended word to quad word instruction, 221

move single precision instruction, 332

move when equal instruction, 393

move with zero extension instruction,

220, 220

move word instruction, 219

move zero-extended byte to double word instruction, 220

move zero-extended byte to word instruction, 220

move zero-extended word to double word instruction, 220

move zero-extended word to quad word instruction, 220

movement operations, floating-point code, 332–337

mov1 [x86-64] move double word, 219

movq [x86-64] move quad word, 219

MOVS [instruction class] move and sign-extend, 220, 221

movsbl [x86-64] move sign-extended byte to double word, 221

movsbq [x86-64] move sign-extended byte to quad word, 221

movsbw [x86-64] move sign-extended byte to word, 221

movslq [x86-64] move sign-extended double word to quad word, 221

movswl [x86-64] move sign-extended word to double word, 221

movswq [x86-64] move sign-extended word to quad word, 221

movw [x86-64] move word, 219

MOVZ [instruction class] move with zero extension, 220, 220

movzbl [x86-64] move zero-extended byte to double word, 220

movzbq [x86-64] move zero-extended byte to quad word, 220

movzbw [x86-64] move zero-extended byte to word, 220

movzw1 [x86-64] move zero-extended word to double word, 220

movzwq [x86-64] move zero-extended word to quad word, 220

---

<!-- Page 1092 -->

mrmovq instruction, 440

mulq [x86-64] unsigned multiply, 234, 234

multi-core processors, 52, 60–61, 204, 641, 1008

multi-level page tables, 855–857

multi-threading, 53–54, 61

Multics, 52

multicycle instructions, 504–505

multidimensional arrays, 294–296

multiple accumulators in parallelism, 572–577

multiple zone recording, 628

multiplexing, I/O, 1009

concurrent programming with,

1014–1021

event-driven servers based on,

1016–1021

pros and cons, 1021

multiplexors, 410, 410–411

HCL with case expression, 414

word-level, 414–416

multiplication

constants, 137–139

floating point, 160, 338

instructions, 234

matrices, 679–683

two’s complement, 133–137

unsigned, 132–133, 234, 234

multiply instruction, 228

multiported random access memory,

418

multipurpose internet mail extensions (MIME) types, 985

multitasking, 769

multiway branch statements, 268–274

munmap [Unix] unmap disk object, 875

mutexes

lock ordering rule, 1065

Pthreads, 1046

for semaphores, 1039

mutual exclusion

progress graphs, 1036

semaphores for, 1038–1040

mutually exclusive access, 1036

\n (newline character), 39, 927

n-gram statistics, 601

named pipes, 928

names

domain, 961, 963–965

mangling and demangling processes

(C++ and Java), 716, 716

protocols, 958

types. 83

Y86-64 pipelines, 463



NaN (not a number)

constants, 160

floating point, 342

representation, 150, 151

nanoseconds (ns), 538

National Science Foundation (NSF), 967

need_regids signal, 441

need_valC signal, 441

NEG [instruction class] negate, 228

negate instruction, 228

negation, two's complement, 131

negative overflow, 126, 126–127

nested arrays, 294–296

nested structures, 304

network byte order, 961

network clients, 57, 954

Network File System (NFS), 646

network programming, 954

client-server model, 954–955

Internet. See Internet

networks, 955–959

sockets interface. See sockets

interface

summary, 1000–1001

TINY Web server, 992–1000

Web servers, 984–992

network servers, 57, 954

networks, 56–57

acyclic, 410

LANs, 956, 956–958

WANs, 957, 957–958

never taken (NT) branch prediction strategy, 464

newline character (\n), 39, 927

next-fit block placement policy, 885, 885

nexti command, 316

NFS (Network File System), 646

NM tool, 749

no-execute (NX) memory protection, 325

no operation nop instruction, 3

instruction code for, 441

pipelining, 466–467

in stack randomization, 322

no-write-allocate approach, 666

nodes, root, 902

nondeterminism, 784

nondeterministic behavior, 784

nonexistent variables, referencing, 910

nonlocal jumps, 759, 817, 817–822

nonuniform partitioning, 452–454

nonvolatile memory, 622

nop [x86-64] no operation instruction

322, 440

instruction code for, 441

pipelining, 466–467

in stack randomization, 322

nop sleds, 322

norace.c [CS:APP] Pthreads program without a race, 1063

normal operation status code, 400, 44

normalized values, floating-point, 149

149–150

northbridge chipsets, 624

not a number (NaN)

constants, 160

floating point, 342

representation, 150,

NOT [instruction class] complement,

228

NOT operation

Boolean, 87–88

C operators, 92–93

logic gates, 409

ns (nanoseconds), 538

NSF (National Science Foundation), 967

NSFNET, 967

NSLOOKUP program, 964

ntohl [Unix] convert network-to-hos long, 961

ntohs [Unix] convert network-to-hos short, 961

number systems conversions. See

conversions

numeric limit declarations, 113

numeric ranges

C standards, 97

integral types, 96–98

Java standard, 104

NX (no-execute) memory protection

325

.o files, 209, 708

-01 optimization flag, 206

-02 optimization flag, 206

OBJDUMP GNU machine-code file reader, 209, 315, 728, 749

object code, 206, 209

object files, 209

executable. See executable object files

formats, 709

forms, 709

relocatable, 41, 708, 709–711

shared, 709

tools, 749

object modules, 709

---

<!-- Page 1093 -->

C++ and Java, 302

memory-mapped, 869–872

private, 870, 870

program, 70

shared, 735, 869–872

as struct, 302–303

oct word, 233, 233–234

OF [x86-64] overflow flag condition code, 237, 391

off-by-one errors, 908

offsets

GOTs, 741, 741–743

memory references, 217

PPOs, 850

unions, 306

VPOs, 850

-0g optimization flag, 206, 599

one-operand multiply instructions,

234

ones’-complement representation, 104

open [Unix] open file, 927, 929–931

open_clientfd [CS:APP] establish connection with server, 978, 978–980

open_listenfd [CS:APP] establish a listening socket, 980, 980

open operations for files, 927, 929–931

open shared library function, 737

open-source operating systems, 122–123

opendir functions, 941

operand specifiers, 216–218

operate instruction, 46

operating systems (OS), 51

operating systems

files, 55

hardware management, 50–51

kernels, 55

Linux, 56, 81

processes, 51–53

threads, 53–54

Unix, 71

virtual memory, 54–55

Windows, 81

operations

bit-level, 90–92

logical, 97–93

optest script, 501

optimization

address translation, 866

compiler, 206

levels, 534

program performance. See

performance

optimization blockers, 532–533, 536

OPTIONS method, 987

or [instruction class] or, 228

or operation

Boolean, 87–88

C operators, 92–93

HCL expressions, 410–411

logic gates, 409

order, bytes, 78–85

disassembled code, 246

network, 961

unions, 308

origin servers, 988

OS. See operating systems (OS)

Ossanna, Joe, 52

out-of-bounds memory references.

See buffer overflow

out-of-order execution, 554

five-stage pipelines, 507

history, 558

overflow

arithmetic, 123, 123–125, 170

buffer. See buffer overflow

floating-point values, 163

identifying, 128–129

infinity representation, 151

multiplication, 138

negative, 126, 126–127

operations, 68

positive, 126, 126–127

overflow flag condition code, 237

overloaded functions (C++ and Java), 716

P semaphore operation, 1037, 1037–1038

P [CS:APP] wrapper function for Posix sem_wait, 1038

P6 microarchitecture, 203

PA (physical addresses), 839

vs. virtual, 839–840

Y86-64, 392

packages, processor, 861

packet headers, 958

packets, 958

padding

alignment, 310–311

blocks, 883

page faults

DRAM caches, 844, 844–845

Linux/x86-64 systems, 765, 869–869

memory caches, 506

pipelining caches, 844

page frames, 841

page hits in caches, 844

page table base registers (PTBRs),

850

page table entries (PTEs), 843,

843–844

Core i7, 862–864

TLBs for, 853–857, 859



page table entry addresses (PTEAs), 853

page tables, 772, 859

caches, 842–844, 843

multi-level, 855–857

paged-in pages, 845

paged-out pages, 845

pages

allocation, 846

demand zero, 869

dirty, 863

physical, 841, 841–842

SSDs, 637

virtual, 325, 841, 841–84

paging

demand, 846

description, 845

parallel execution, 770

parallel flows, 770, 770

parallelism, 60, 572

instruction-level, 62, 533, 554, 598

multiple accumulators, 572–577

reassociation transformations, 577–582

SIMD, 62, 582–583

thread-level, 62

threads for, 1049–1054

parent directories, 928

parent processes, 775, 775–776

parity flag condition code, 214, 342

parse_uri [CS:APP] TINY helper function, 996

parseline [CS:APP] shell helper

routine, 792

partitioning

addresses, 651–652

nonuniform in pipelining, 452–454

passing data

machine-language procedures, 275

pointers to structures, 302

pathnames, 929

Patterson, David, 397, 507

pause [Unix] suspend until signal arrives, 786

payloads

aggregate, 881

Ethernet, 956

protocol, 958

PC. See program counters (PCs)

PC-relative addressing jumps, 243, 243–245

---

<!-- Page 1094 -->

symbol references, 726, 728–729

Y86-64, 395

- section stage in PIPE processor, 483–485

PC update stage

instruction processing, 421, 423–431

sequential processing, 436

sequential Y86-64 implementation, 447

PCI (peripheral component interconnect), 634

PCIe (PCI express), 634

PE (Portable Executable) format, 709

peak utilization metric, 880–881, 881

peer threads, 1022

pending bit vectors, 795

pending signals, 794

Pentium II microprocessor, 203

Pentium III microprocessor, 203–204

Pentium 4 microprocessor, 204

Pentium 4E microprocessor, 204

Pentium microprocessor, 203

PentiumPro microprocessor, 203, 558

performance, 42

Amdahl's law, 58–60

basic strategies, 597–598

bottlenecks, 598–604

branch prediction and misprediction penalties, 585–589

caches, 589, 667–669, 675–683

compiler capabilities and limitations, 534–538

expressing, 538–540

limiting factors, 584–589

loop inefficiencies, 544–548

loop unrolling, 567, 567–571

memory, 589–597

memory references, 550–553

modern processors, 554–567

overview, 532–534

parallelism. See parallelism procedure calls, 548–549

program example, 540–544

program profiling, 598–600

register spilling, 584–585

results summary, 583–584

sequential Y86-64 implementation, 448

summary, 604–605

Y86-64 pipelining, 500–504

periods (.) in dotted-decimal notation, 962

persistent connections in HTTP, 988

PF [x86-64] parity flag condition code, 214, 342

physical address spaces, 840

physical addresses (PA), 839

vs. virtual, 839–840

Y86-64, 392

physical page numbers (PPNs), 850

physical page offset (PPO), 850

physical pages (PPs), 841, 841–842

pi in floating-point representation, 176

PIC (position-independent code), 740

data references, 740–741

function calls, 741–743

picoseconds (ps), 449, 538

PIDs (process IDs), 775

pins, DRAM, 618–619

PIPE- processor, 457, 458, 462–466

PIPE processor stages, 475–476, 483

decode and write-back, 485–489

execute, 489–490

memory, 490–491

PC selection and fetch, 483–485

pipelining, 62, 251, 448

bubble, 470

  combinational, 448–450

  deep, 454–455

  diagram, 449

  five-stage, 507

  functional units, 559–560

  instruction, 585

  limitations, 452–454

  nonuniform partitioning, 452–454

  operation, 450–452

  registers, 449, 463

  store operation, 591–592

  systems with feedback, 455–457

  Y86-64. See Y86-64 pipelined implementations

pipes, 1013

Pisano, Leonardo (Fibonacci), 68

placement

memory blocks, 883, 885

policies, 648, 885

platters, disk, 626, 627

PLT (procedure linkage table), 742, 742–743

PMAP tool, 822

point-to-point connections, 965

pointers, 70

arithmetic, 293–294, 909

arrays relationship to, 84, 313

block, 892

creating, 84, 224

declaring, 77

dereferencing, 84, 224, 293, 313, 906–907

examples, 224

to functions, 314

machine-level data, 213

principles, 314

role, 72

stack, 275

to structures, 302

virtual memory, 906–909

void*, 84



polynomial evaluation, 566, 566, 608–609

pools of peer threads, 1023

pop instructions in x86-64 models, 40

pop operations on stack, 225, 225–227

popq [Y86-64] pop instruction, 226, 226, 393

behavior of, 407

code for, 440

run-time stack, 275

portability and data type size, 77

Portable Executable (PE) format, 709

portable signal handling, 810–811

.pos [Y86-64] directive, 402

position-independent code (PIC), 746

data references, 740–741

function calls, 741–743

positive overflow, 126, 126–127

posix_error [CS:APP] reports Posix-style errors, 1079

Posix standards, 52

Posix-style error handling, 1078, 1079

Posix threads, 1023, 1023–1024

POST method, 987–989

PowerPC

processor family, 388, 397

RISC design, 397–399

powers of 2, division by, 139–143

PPNs (physical page numbers), 850

PPO (physical page offset), 850

PPs (physical pages), 841, 841–842

precedence of shift operations, 95

precision, floating-point, 149, 173

prediction

branch, 251

misprediction penalties, 585–589

Y86-64 pipelining, 458, 463–465

preempted processes, 769

prefetching mechanism, 677–678

prefix sums, 538, 539, 597, 609

prepare stack for return instruction 328

preprocessors, 41, 206

prethreading, 1041–1049, 1044

primary inputs in logic gates, 410

---

<!-- Page 1095 -->

principle of locality, 640, 640

print command, 316

print getaddrinfo error message

function, 974

printf [C Stdlib] formatted printing function

formatted printing, 83

numeric values with, 111

printing, formatted, 83

priorities

PIPE processor forwarding sources,

487–488

write ports, 444

private address space, 770

private areas, 870

private copy-on-write structures, 872

private declarations (C++ and Java),

713

private objects, 870, 870

privileged instructions, 771

/proc filesystem, 771, 771–772, 822

procedure linkage table (PLT), 742, 742–743

procedure return instruction, 393

procedures, 274–275

call performance, 548–549

control transfer, 277–281

data transfer, 281–284

floating-point code in, 337–338

recursive, 289–291

register usage conventions, 287–292

run-time stack, 275–277

process contexts, 52, 772

process graphs, 777, 778

process groups, 795

process IDs, 775

process tables, 772

processes, 51, 768, 774

background, 789

child, 776

concurrent flow, 768–770, 769

concurrent programming with, 1009–1013

concurrent servers based on, 1010–1011

context switches, 772–773

creating and terminating, 775–779

default behavior, 780

error conditions, 781–782

exit status, 781

foreground, 789

group, 795

IDs, 775–776

loading programs, 735, 786–788

overview, 51–53

parent, 775, 776

preempted, 769

private address space, 770

vs. programs, 789

pros and cons, 1011

reaping, 779, 779–785

running programs, 786–792

sleeping, 785–786

tools, 822–823

user and kernel modes, 770–77

waitpid function, 782–785

zombie, 779

processor-memory gap, 49, 640

processor packages, 861

processor states, 759

processors. See central processing units (CPUs)

producer-consumer problem, 1040, 1041–1042

profilers code, 533

profiling, program, 598–600

program counters (PCs), 45, 80

in fetch stage, 420

hazards, 471

machine-language procedures, 275

%rip, 207

SEQ timing, 437

Y86-64 instruction set architecture, 392

Y86-64 pipelining, 459, 463–465

program data references locality, 642–643

program header tables, 732, 732

program registers

clocked, 417–420

data hazards, 471

Y86-64, 391–392

programmable ROMs (PROMs), 623

programmer-visible state, 391, 391–392

programs

code and data, 54

concurrent. See concurrent

programming

forms, 40–41

loading and running, 786–788

machine-level. See machine-level

programming

objects, 70

vs. processes, 789

profiling, 598–600

running, 46–48, 789–792

Y86-64, 400–406

progress graphs, 1035, 1035–1037

deadlock regions, 1063–1064, 1064

forbidden regions, 1039

limitations, 1040



prologue blocks, 891

PROMs (programmable ROMs), 623

protection, memory, 848–849

protocol software, 958

protocols, 958

proxy caches, 988

proxy chains, 988

ps (picoseconds), 449, 538

ps tool, 822

pseudorandom number generator

functions, 1057

psum-array.c [CS:APP] parallel sum program using array, 1052

psum-local.c [CS:APP] parallel sum program using local variables, 1053

psum-mutex.c [CS:APP] parallel sum program using mutex, 1051

PTBRs (page table base registers), 850

PTEAs (page table entry addresses), 853

PTEs (page table entries), 843, 843–844

Core i7, 862–864

TLBs for, 853–857, 859

pthread_cancel [Unix] terminate another thread, 1025

pthread_create [Unix] create a thread, 1024

pthread_detach [Unix] detach thread, 1026, 1026

pthread_exit [Unix] terminate current thread, 1025

pthread_join [Unix] reap a thread,

1025

pthread_once [Unix] initialize a thread, 1026, 1048

pthread_self [Unix] get thread ID,

1024

Pthreads, 1023, 1023–1024, 1046

public declarations (C++ and Java), 713

push instructions in x86-64 models, 408

push operations on stack, 225, 225–227

pushq [x86-64] push quad word, 209,

226, 226, 393

code for, 440

processing steps, 406–407, 428

run-time stack, 275

PUT method in HTTP, 987

“put to” operator (C++), 926

---

<!-- Page 1096 -->

qsort function, 602

quad words, 213

QuickPath interconnect, 624, 862

quit command, 316

R_X86_64_32 (absolute addressing), 727

R_X86_64_PC32 (PC-relative addressing), 726

symbol table entry, 713

and Unix, 709

%r8 [Y86-64] program register, 216, 391

%r8d [x86-64] low order 32 bits of register %r8, 216

%r8w [x86-64] low order 16 bits of register %r8, 216

%r9 [Y86-64] program register, 216, 391

%r9d [x86-64] low order 32 bits of register %r9, 216

%r9w [x86-64] low order 16 bits of

register %r9, 216

%r10 [Y86-64] program register, 216, 391

%r10d [x86-64] low order 32 bits of

register %r10, 216

%r10w [x86-64] low order 16 bits of

register %r10, 216

%r11 [Y86-64] program register, 216, 391

%r11d [x86-64] low order 32 bits

register %r11, 216

%r11w [x86-64] low order 16 bits of

register %r11, 216

%r12 [Y86-64] program register, 216, 391

%r12d [x86-64] low order 32 bits of register %r12, 216

%r12w [x86-64] low order 16 bits of

register %r12, 216

%r13 [Y86-64] program register, 216, 391

%r13d [x86-64] low order 32 bits of

register %r13, 216

%r13w [x86-64] low order 16 bits of

register %r13, 216

%r14 [Y86-64] program register, 216, 391

%r14d [x86-64] low order 32 bits of register %r14, 216

%r14w [x86-64] low order 16 bits of

register %r14, 216

%r15 [x86-64] program register, 216,

391

%r15d [x86-64] low order 32 bits of

register %r15, 216



%r15w [x86-64] low order 16 bits of register %r15, 216

race.c [CS:APP] program with a race, 1061

race conditions, 812, 1028

concurrent programming, 1061,

1061–1063

signals, 812–814

rand [CS:APP] pseudorandom number generator, 1057, 1060

rand_r function, 1060

random access memory (RAM, 617

dynamic. See dynamic RAM (DRAM)

multiported, 418

processors, 420

SEQ timing, 437

static. See static RAM (SRAM)

random operations in SSDs, 636

random replacement policies, 648

ranges

asymmetric, 102, 113

bytes, 72

constants for, 103–104

data types, 76

integral types, 96–98

Java standard, 104

RAS (row access strobe) requests, 619

%rax [Y86-64] program register, 216, 391

%rbp [Y86-64] program register, 216, 391

%rbx [Y86-64] program register, 216, 391

%rcx [Y86-64] program register, 216, 391

%rdi [Y86-64] program register, 216, 391

%rdx [Y86-64] program register, 216, 391

reachability graphs, 902

reachable nodes, 902

read access, 325

read and echo input lines function,

983

read bandwidth, 675

read environment variable function,

787

read/evaluate steps, 789

read [Unix] read file, 931, 931–933

read-only memory (ROM), 622



read-only register, 563

read operations

buffered, 934, 936–937

disk sectors, 633–635

file metadata, 939–940

files, 927, 931–933

SSDs, 637

unbuffered, 933–934

uninitialized memory, 90

read ports, 418

read_requesthdrs [CS:APP] TINY helper function, 996

read sets, 1014

read throughput, 675

read transactions

descriptions, 623

example of, 624–625

read/write heads, 628

readdir functions, 941

READELF GNU object file reader, 714

749

readers-writers problem, 1042, 1044

reading

directory contents, 941–942

disk sectors, 633

readline function, 939

readn function, 939

ready read descriptors, 1014

ready sets, 1014

realloc function, 877

reap thread function, 1025

reaping

child processes, 779, 779–785

threads, 1025

rearranging signals in pipelining, 462–463

reassociation transformations, 577, 577–582, 606

receiving signals, 794, 798–800

recording density, 627

recording zones, 628

recursive procedures, 289–291

redirection of I/O, 945, 945–946

reduced instruction set computers (RISC), 397

vs. CISC, 397–399

SPARC processors, 507

reentrancy issues, 1059–1060

reentrant functions, 802, 1059

reference bits, 863

reference counts, 942

reference machines, 543

referencing

data in free heap blocks, 910–911

---

<!-- Page 1097 -->

nonexistent variables, 910

refresh, DRAM, 618

regions, deadlock, 1063–1064, 1064

register files, 46, 394

contents, 418–419, 557

purpose, 394–395

SEQ timing, 437

register identifier (ID), 394–395

register operands, 217

register specifier bytes in Y86-64 instruction, 394

register to memory move instruction,

392

register to register move instruction,

392

egisters, 45

clocked, 417

data hazards, 471

data transfer, 281–284

hardware, 417–420

local, 563

local storage, 287–289

loop, 563

program, 391–392, 417–420, 471

read-only, 563

register files, 207

renaming, 558

spilling, 584–585

updating conventions, 215

write-only, 563

x86-64 integer, 215, 215–216

Y86-64, 395, 458–462

egular files, 869, 927

rel.data section, 711

rel.text section, 711

elabeling signals, 462–463

relative pathnames, 929

relative speedup in parallel programs,

1055

reliable connections, 966

relocatable object files, 41, 708, 709–711

relocation, 709, 725–726

algorithm, 727

entries, 726, 726–727

PC-relative references, 728–729

practice problems, 730–731

remove item from bounded buffer function, 1043

renaming registers, 558

rep [x86-64] string repeat instruction used as no-op, 244

~placing blocks, 648

report shared library error function,

738

reporting errors, 1079

request headers in HTTP, 987

request lines in HTTP, 987

requests

client-server model, 954

HTTP, 987, 987–988

requests for comments (RFCs), 1001

reset configuration in pipelining, 496

resident sets, 846

resources

client-server model, 954

shared, 1040–1044

response bodies in HTTP, 988

response headers in HTTP, 988

response lines in HTTP, 988

responses

client-server model, 954

HTTP, 988, 988–989

restart.c [CS:APP] nonlocal jump example, 821

restrictions, alignment, 309–312

ret [Y86-64] procedure return, 393

ret [x86-64] return from procedure call, 244, 277–278

ret instruction, 440

processing steps, 431

Y86-64 pipelining, 464–465, 491–493, 497–498

retiming circuits, 457

retirement units, 557

retq [x86-64] return from procedure, 277

return addresses, 277

predicting, 465

procedures, 276

return penalty in CPI, 503

reverse engineering

loops, 258

machine code, 201

revolutions per minute (RPM), 626

RFCs (requests for comments), 1001

ridges in memory mountains, 677

right hoinkies (>), 946

right shift operations, 93–94, 228

rings, Boolean, 88

RIO [CS:APP] Robust I/O package, 933

buffered functions, 934–938

origins, 939

unbuffered functions, 933–934

rio_read [CS:APP] internal read function, 937

rio_readinitb [CS:APP] init read buffer, 934, 936



rio_readline [CS:APP] robust

buffered read, 934, 938

rio_readn [CS:APP] robust unbuffered read, 933, 933–935, 937, 939

rio_readnb [CS:APP] robust

buffered read, 934, 938

rio_t [CS:APP] read buffer, 936

rio_written [CS:APP] robust unbuffered write, 933, 933–935, 939

rip [x86-64] program counter, 207

%rip program counter, 207

RISC (reduced instruction set computers), 397

vs. CISC, 397–399

SPARC processors, 507

Ritchie, Dennis, 38, 40, 52, 71, 950

rmdir command, 928

rmmovq [Y86-64] register to memory

move, 392, 426, 440

RNONE [Y86-64] ID for indicating no register, 440

Roberts, Lawrence, 967

robust buffered read functions, 934, 938

Robust I/O (Rio) package, 933

buffered functions, 934–938

origins, 939

unbuffered functions, 933–93

robust unbuffered read function, 933, 933–935

robust unbuffered write function, 933, 933–935

.rodata section, 710

ROM (read-only memory), 622

root directory, 928

root nodes, 902

rotating disks term, 627

rotational latency of disks, 630

rotational rate of disks, 626

round-down mode, 157, 157

round-to-even mode, 156, 156–157, 160

round-to-nearest mode, 156, 156

round-toward-zero mode, 156, 156–157

round-up mode, 157, 157

rounding

in division, 141–142

floating-point representation,

156–158

rounding modes, 156, 156–158

routers, Ethernet, 957

---

<!-- Page 1098 -->

routines, thread, 1023

row access strobe (RAS) requests, 619

row-major array order, 294, 642

row-major sum function, 671, 671

RPM (revolutions per minute), 626

rrmovq [Y86-64] register to register move, 392, 440

%rsi [x86-64] program register, 216

%rsp [Y86-64] stack pointer program register215-216, 391

run command, 316

run concurrency, 769

run time

interpositioning, 746–748

linking, 706

shared libraries, 735

stacks, 207, 275–277

running

in parallel, 770

processes, 775

programs, 46–4

.s assembly language files, 708

SA [CS:APP] shorthand for struct sockaddr, 969

SADR [Y86-64] status code for address exception, 440

safe optimization, 534, 534–535

safe signal handling, 802–806

safe trajectories in progress graphs,

1036

safely emit error message and

terminate instruction, 802,

804

safely emit long int instruction, 802

804

safely emit string instruction, 802, 804

SAL [instruction class] shift left, 228

salb [x86-64] shift left, 231

salq [x86-64] shift left, 231

salw [x86-64] shift left, 231

Sandy Bridge microprocessor, 204

SAOK [Y86-64] status code for normal operation, 440

SAR [instruction class] shift arithmetic right, 228, 231

SATA interfaces, 633

saturating arithmetic, 170

sbrk [C Stdlib] extend the heap, 877, 877

emulator, 891

heap memory, 886

Sbuf [CS:APP] shared bounded buffer package, 1041, 1042

sbuf_deinit [CS:APP] free bounded buffer, 1043

sbuf_init [CS:APP] allocate and init bounded buffer, 1043



sbuf_insert [CS:APP] insert item in a bounded buffer, 1043

sbuf_remove [CS:APP] remove item from bounded buffer, 1043

sbuf_t [CS:APP] bounded buffer used by SBUF package, 1042

scalar code performance summary, 583–584

scalar format data, 330

scalar instructions, 332

scale factor in memory references, 217

scaling parallel programs, 1055, 1055–1056

scanf function, 906–907

schedule alarm to self function, 798

schedulers, 772

scheduling, 772

events, 799

shared resources, 1040–1044

SCSI interfaces, 633

SDRAM (synchronous DRAM), 622

second-level domain names, 964

second readers-writers problem, 1044

sectors, disk, 626, 626–628

access time, 629–631

gaps, 632

reading, 633–635

security monoculture, 321

seeds for pseudorandom number generators, 1057

seek operations, 629, 927

seek time for disks, 629, 629

segmentation faults, 765

segmented addressing, 323–324

segments

code, 732, 733–734

data, 732

Ethernet, 956, 956

loops, 562–563

virtual memory, 866

segregated fits, 899, 900–901

segregated free lists, 899–901

segregated storage, 899

select [Unix] wait for I/O events,

1013

self-loops, 1016

self-modifying code, 471

sem_init [Unix] initialize semaphore,

1038

sem_post [Unix] V operation, 1038

sem_wait [Unix] P operation, 1038

semaphores, 1037, 1057–1058

concurrent server example, 1041–1049

for mutual exclusion, 1038–1040

for scheduling shared resources, 1040–1044



sending signals, 771, 795–798

separate compilation, 706

SEQ+ pipelined implementations, 457, 457–458

SEQ Y86-64 processor design

See sequential Y86-64

implementation

sequential circuits, 417

sequential execution, 236–237

sequential operations in SSDs, 636

sequential reference patterns, 642

sequential Y86-64 implementation

420, 457

decode and write-back stage,

442–444

execute stage, 444–445

fetch stage, 440–442

hardware structure, 432–436

instruction processing stages,

420–431

memory stage, 445–447

PC update stage, 447

performance, 448

SEQ+ implementations, 457,

457–458

timing, 436–439

serve_dynamic [CS:APP] TINY helper function, 999–1000

serve_static [CS:APP] TINY help function, 997–999

servers, 57

client-server model, 954

concurrent. See concurrent serve

network, 57

Web. See Web servers

service conversions in sockets interface, 973–978

services in client-server model, 954

serving

dynamic content, 989–990

Web content, 985

set associative caches, 660

line matching and word selection

661–662

line replacement, 661

set selection, 661, 661

set bit in descriptor set macro, 1014

set index bits, 651, 651–652

set on equal instruction, 239

set on greater instruction, 239

---

<!-- Page 1099 -->

or on greater or equal instruction, 239

set on less instruction, 239

set on less or equal instruction, 239

set on negative instruction, 239

set on nonnegative instruction, 239

set on not equal instruction, 239

set on not greater instruction, 239

set on not greater or equal instruction,

239

set on not less instruction, 239

set on not less or equal instruction,

239

set on not zero instruction, 239

set on unsigned greater instruction,

239

set on unsigned greater or equal instruction, 239

set on unsigned less instruction, 239

set on unsigned less or equal instruction, 239

set on unsigned not greater instruction,

239

set on unsigned not less instruction,

239

set on unsigned not less or equal instruction, 239

set on zero instruction, 239

set process group ID function, 795

set selection

direct-mapped caches, 654

fully associative caches, 661

set associative caches, 661

seta [x86-64] set on unsigned greater,

239

setae [x86-64] set on unsigned greater

or equal, 239

setb [x86-64] set on unsigned less, 239

setbe [x86-64] set on unsigned less or equal, 239

sete [x86-64] set on equal, 239

setenv [Unix] create/change environment variable, 788

setg [x86-64] set on greater, 239

setge [x86-64] set on greater or equal,

239

set jmp [C Stdlib] init nonlocal jump,

759,817,819

set jmp.c [CS:APP] nonlocal jump

example, 820

set1 [x86-64] set on less, 239

setle [x86-64] set on less or equal,

239

setna [x86-64] set on unsigned not greater, 239

setnae [x86-64] set on unsigned not less or equal, 239 setnb [x86-64] set on unsigned not less, 239



setnbe [x86-64] set on unsigned not less or equal, 239

setne [x86-64] set on not equal, 239

setng [x86-64] set on not greater, 239

setnge [x86-64] set on not greater or equal, 239

setnl [x86-64] set on not less, 239

settle [x86-64] set on not less or equal, 239

setns [x86-64] set on nonnegative,

239

setnz [x86-64] set on not zero, 239

setpgid [Unix] set process group ID,

795

sets

vs. cache lines, 670

membership, 416–417

sets [x86-64] set on negative, 239

setz [x86-64] set on zero, 239

SF [x86-64] sign flag condition code, 237, 391

sh [Unix] Unix shell program, 789

Shannon, Claude, 87

shared areas, 870

shared libraries, 55, 735

dynamic linking with, 735–737

loading and linking from

applications, 737–739

shared object files, 709

shared objects, 735, 869–872, 870

shared resources, scheduling, 1040–1044

shared variables, 1028–1031, 1029

sharing

files, 942–944

virtual memory for, 848

sharing.c [CS:APP] sharing in Pthreads programs, 1029

shellex.c [CS:APP] shell main routine, 790

shells, 43, 789

shift arithmetic right instruction, 228

shift left instruction, 228

shift logical right instruction, 228

shift operations, 93, 93–95

for division, 139–143

machine language, 230–232

for multiplication, 137–139

shift arithmetic right instruction, 228

shift left instruction, 228

shift logical right instruction, 228

SHL [instruction class] shift left, 228, 231

SHLT [Y86-64] status code for halt, 440



short counts, 931

short [C] integer data type, 76, 97

SHR [instruction class] shift logical right, 228, 231

%si [x86-64] low order 16 bits of register %rsi, 216

side effects, 536

sig_atomic_t type, 806

sigaction [Unix] install portable handler, 811

sigaddset [Unix] add signal to signal set, 801

sigdelset [Unix] delete signal from signal set, 801

sigemptyset [Unix] clear a signal set,

801

sigfillset [Unix] add every signal to signal set, 801

sigint.c [CS:APP] catches SIGINT signal, 799

sigismember [Unix] test signal set membership, 801

siglongjmp [Unix] init nonlocal jump, 819, 821

sign bits

floating-point representation, 173

two’s complement representation,

100

sign extension, 113, 113, 219–220

sign flag condition code, 237, 391

sign-magnitude representation, 104

Signal [CS:APP] portable version of

signal, 811

signal handlers, 794

installing, 799

writing, 802–811

Y86-64, 400

signal1.c [CS:APP] flawed signal handler, 807

signal2.c [CS:APP] flawed signal handler, 808

signals, 758, 792–794

blocking and unblocking, 800

correct handling, 806–810

enabling and disabling, 88

flow synchronizing, 812–814

portable handling, 810–811

processes, 775

receiving, 798, 798–800

safe handling, 802–806

sending, 794, 795–798

terminology, 794–795

waiting for, 814–817

---

<!-- Page 1100 -->

180-04 pipelined implementations, 462–463

signed [C] integer data type, 77

gned divide instruction, 234, 235

signed integers, 68, 76, 97–98, 103

alternate representations, 104

shift operations, 94

two’s complement encoding, 100–106

unsigned conversions, 106–112

signed multiply instruction, 234, 234

signed number representation

guidelines, 119–120

ones’ complement, 104

sign magnitude, 104

signed size type, 932

significands in floating-point

representation, 148

signs for floating-point representation,

148, 148–149

SIGPIPE signal, 1000

sigprocmask [Unix] block and

unblock signals, 801, 817

sigsetjmp [Unix] init nonlocal

handler jump, 817, 821

sigsuspend [Unix] wait for a signal,

817

%sil [x86-64] low order 8 of register %rsi, 216

SimAquarium game, 673–674

SIMD (single-instruction, multiple-data) parallelism, 62, 330, 582, 583

SIMD streaming extensions (SSE)

instructions, 312

simple segregated storage, 899, 899–900

simplicity in instruction processing,

421

simulated concurrency, 60

simultaneous multi-threading, 61

single-bit data connections, 434

single-instruction, multiple-data (SIMD) parallelism, 62, 330, 582–583

single-precision floating-point representation

IEEE, 149, 149

machine-level data, 214

support for, 77

SINS [Y86-64] status code for illegal instruction exception, 440

sio_error [CS:APP] safely emit error message and terminate, 802, 804

sio_ltoa [CS:APP] safely emit string,

804

sio_putl [CS:APP] safely emit long

int, 802, 804



sio_puts [CS:APP] safely emit string,

802, 804

sio_strlen [CS:APP] safely emit string, 804

size

blocks, 884

caches, 668–669

data, 75–78

word, 44, 75

size classes, 899

size_t [Unix] unsigned size type for designating sizes, 80, 119–120, 122, 135, 932

size tool, 749

sizeof [C] compute size of object, 81, 165–167, 169

slashes (/) for root directory, 928

sleep [Unix] suspend process, 785

slow system calls, 810

.so shared object file, 735

sockaddr [Unix] generic socket address structure, 969

sockaddr_in [Unix] Internet-style socket address structure, 969

socket addresses, 966

socket descriptors, 948, 970

socket function, 970

socket pairs, 966

sockets, 928, 966

sockets interface, 968, 968–969

accept function, 972–973

address structures, 969–970

bind function, 971

connect function, 970–971

example, 980–983

helper functions, 978–980

host and service conversions, 973–978

listen function, 971

open_clientfd function, 970–971

socket function, 970

Software Engineering Institute, 136

software exceptions

C++ and Java, 822

ECF for, 759–760

vs. hardware, 760

Solaris Sun Microsystems operating system, 52, 81

solid state disks (SSDs), 627, 636

benefits, 623

operation, 636–638

sorting performance, 602–603

source files, 39

source hosts, 958

source programs, 39

southbridge chipsets, 624

Soviet Union, 967

%sp [x86-64] low order 16 bits of sta

pointer register %rsp, 216

SPARC

five-stage pipelines, 507

RISC processors, 399

Sun Microsystems processor, 8

spare cylinders, 632

spatial locality, 640

caches, 679–683

exploiting, 650

special arithmetic operations, 233–236

special control conditions in Y86-64

pipelining

detecting, 493–495

handling, 491–493

specifiers, operand, 216–218

speculative execution, 555, 555, 585–586

speedup of parallel programs, 1054, 1054–1055

spilling, register, 584–585

spin loops, 814

spindles, disks, 626

%spl [x86-64] low order 8 of stack

pointer register %rsp, 216

splitting

free blocks, 885–886

memory blocks, 883

sprintf [C Stdlib] function, 83, 318

Sputnik, 967

sqrtsd [x86-64] double-precision square root, 338

sqrtss [x86-64] single-precision square root, 338

square root floating-point instructions,

338

squashing mispredicted branch handling, 480

SRAM (static RAM), 49, 617, 617–618

cache. See caches and cache memory

vs. DRAM, 618

trends, 638–639

SRAM cells, 617

srand [CS:APP] pseudorandom number generator seed, 1057

SSDs (solid state disks), 627, 636

benefits, 623

operation, 636–638

SSE (streaming SIMD extensions)

instructions, 203–204, 330

alignment exceptions, 312

parallelism, 582–583

ssize_t [Unix] signed size type, 932

---

<!-- Page 1101 -->

stack corruption detection, 322–325

stack frames, 276, 276–277

alignment on, 312

variable-size, 326–329

stack pointers, 275

stack protectors, 322–323

stack randomization, 320–322

stack storage allocation function, 326, 360

stacks, 55, 225, 225–227

blacks, 55, 225, 225

bottom, 226

buffer overflow, 907

with execve function, 787–788

local storage, 284–287

machine-level programming, 20

overflow. See buffer overflow

recursive procedures, 289–291

run time, 275–277

top, 226

Y86-64 pinelining, 465

tages, SEQ, 420–431

decode and write-back, 442–444

execute, 444–445

fetch, 440–442

memory stage, 445–447

PC update, 447

stalling

for data hazards, 478

pipeline, 469–472, 495–496

Stallman, Richard, 42, 52

standard C library, 40, 40–41

standard error files, 927

standard I/O library, 947, 947

standard input files, 927

standard output files, 927

Standard Unix Specification, 52

_start, 734

starvation in readers-writers problem, 1044

stat [Unix] fetch file metadata, 939–940

state machines, 1016

states

bistable memory, 617

deadlock, 1063

processor, 759

programmer-visible, 391, 391–392

progress graphs, 1035

state machines, 1016

static libraries, 720, 720–724

static linkers, 708

static linking, 708

static RAM (SRAM), 49, 617–618

cache. See caches and cache memory

vs. DRAM, 618

trends, 638–639



static [C] variable and function attribute, 712, 713, 1030

static variables, 1030, 1030–1031

static Web content, 985

status code registers, 471

status codes

HTTP, 989

Y86-64, 399

status messages in HTTP, 989

status register hazards, 471

STDERR_FILENO [Unix] constant for standard error descriptor, 927

stderr stream, 947

STDIN_FILENO [Unix] constant for standard input descriptor, 927

stdin stream, 947

stdint.h file, 103

<stdio.h> [Unix] standard I/O library header file, 120, 122

stdlib, 40, 40–41

STDOUT_FILENO [Unix] constant for standard output descriptor, 927

stdout stream, 947

stepi command, 316

stepi4 command, 316

Stevens, W. Richard, 939, 950, 1001, 1077

stopped processes, 775

storage. See also information storage device hierarchy, 50 registers, 287–289 stack, 284–287

storage classes for variables, 1030–1031

store buffers, 593–594

store instructions, 46

store operations

example, 624

processors, 557

store performance of memory, 591–597

STRACE tool, 822

straight-line code, 236–237

strcat [C Stdlib] string concatenation function, 318

strcpy [C Stdlib] string copy function, 318

streaming SIMD extensions (SSE)

instructions, 203–204, 330

alignment exceptions, 312

parallelism, 582–583

streams, 947

buffers, 947

directory, 941

full duplex, 948

strerror function, 774

stride-1 reference patterns, 642

stride-k reference patterns, 642

string concatenation function, 318

string generation function, 318

strings

in buffer overflow, 315, 317

length, 119

lowercase conversions, 545–547

representing, 85

STRINGS tool, 749

STRIP tool, 749

strlen [C Stdlib] string length function, 119, 545–547

strong scaling, 1055

.strtab section, 711

strtok [C Stdlib] string function, 1060

struct [C] structure data type, 301

structures

address, 969–970

heterogeneous. See heterogeneous

data structures

machine-level programming, 207

SUB [instruction class] subtract, 228

subdomains, 963

subq [Y86-64] subtract, 392, 424

substitution, inline, 537

subtract instruction, 228

subtract operation in execute stage,

444

subtraction, floating-point, 338

sumarraycols [CS:APP] column-

major sum, 672

sumarrayrows [CS:APP] row-major

sum, 671, 671

sumvec [CS:APP] vector sum, 670, 671–672

Sun Microsystems, 81

five-stage pipelines, 507

RISC processors, 399

security vulnerability, 136

supercells, 618, 618–619

superscalar processors, 62, 507, 554

supervisor mode, 771

surfaces, disks, 626, 631

suspend process function, 785

suspend until signal arrives function,

786

suspended processes, 775

swap areas, 869

swap files, 869

swap space, 869

swapped-in pages, 845

---

<!-- Page 1102 -->

swapped-out pages, 845

swapping pages, 845

sweep phase in Mark&Sweep garbage collectors, 903

Swift, Jonathan, 79

switch [C] multiway branch statement, 268–274

switches, context, 772–773

symbol resolution, 709, 715

duplicate symbol names, 716–720

static libraries, 720–724

symbol tables, 711, 711–715

symbolic links, 928

symbolic methods, 502

symbols

address translation, 850

caches, 653

global, 711

local, 712

relocation, 725–731

strong and weak, 716

.symtab section, 711

synchronization

flow, 812–814

Java threads, 1046

progress graphs, 1036

threads, 1031–1035

progress graphs, 1035–1037

with semaphores. See semaphores

synchronization errors, 1031

synchronous DRAM (SDRAM), 622

synchronous exceptions, 763

/sys filesystem, 772

system calls, 53, 763, 763–764

error handling, 773–774

Linux/x86-64 systems, 766–767

slow, 810

system-level functions, 766

system-level I/O

closing files, 930–931

file metadata, 939–940

I/O redirection, 945–946

opening files, 929–931

packages summary, 947–9

reading files, 931–933

Rio package, 933–939

sharing files, 942–944

standard, 947

summary, 949–950

Unix I/O, 926–927

writing files, 932–933

system startup function, 734

System V Unix, 52

semaphores, 1013

shared memory, 1013

T2B (two's complement to binary conversion), 96, 101, 107  

T2U (two's complement to unsigned conversion), 96, 107, 107–109  

tables  

    descriptor, 943, 945  

    exception, 761, 761  

    GOTs, 741, 741–743  

    hash, 603–604  

    header, 710, 732  

    jump, 269, 270–271, 761  

    page, 772, 842–844, 843, 855–857, 859  

    program header, 732, 732  

    symbol, 711, 711–715  

    tag bits, 651, 652  

    tags, boundary, 887, 887–890, 895  

    Tanenbaum, Andrew S., 56  

    target functions in interpositioning libraries, 744  

    targets, jump, 242, 242–245  

    TCP (Transmission Control Protocol), 960  

    TCP/IP (Transmission Control Protocol/Internet Protocol), 960  

    tcsh [Unix] Unix shell program, 789  

    TELNET remote login program, 986, 986–987  

    temporal locality, 640  

    blocking for, 683  

    exploiting, 650  

    terminate another thread function, 1025  

    terminate current thread function, 102  

    terminate process function, 775  

    terminated processes, 775  

    terminating  

    processes, 775–779  

    threads, 1024–1025  

    TEST [instruction class] Test, 238  

    test byte instruction, 238  

    test double word instruction, 238  

    test instructions, 238  

    test quad word instruction, 238  

    test signal set membership instruction 801  

    test word instruction, 238  

    testb [x86-64] test byte, 238  

    testing Y86-64 pipeline design, 501  

    test1 [x86-64] test double word, 238

testq [x86-64] test quad word, 256

testw [x86-64] test word, 238

text files, 39, 927, 928, 936

text lines, 927, 934

text representation

ASCII, 85

Unicode, 86

.text section, 710

Thompson, Ken, 52

thrashing

direct-mapped caches, 658, 658–65

pages, 846

thread contexts, 1022, 1029

thread IDs (TIDs), 1022

thread-level concurrency, 60–62

thread-level parallelism, 62

thread routines, 1023, 1024

thread-safe functions, 1056, 1056–105

thread-unsafe functions, 1056, 1056–1058

threads, 53, 54, 1009, 1021–1022

concurrent server based on, 1027–1028

creating, 1024

detaching, 1025–1026

execution model, 1022–1023

initializing, 1026

library functions for, 1060–1061

mapping variables in, 1030–1031

memory models, 1029–1030

for parallelism, 1049–1054

Posix, 1023–1024

races, 1061–1063

reaping, 1025

safety issues, 1056–1058

shared variables with, 1028–1031

synchronizing, 1031–1035

progress graphs, 1035–1037

with semaphores. See semaphores

terminating, 1024–1025

three-stage pipelines, 450–452

throughput, 560

dynamic memory allocators, 881

pipelining for. See pipelining

read, 675

throughput bounds, 554, 560

TIDs (thread IDs), 1022

time slicing, 769

timing, SEQ, 436–439

TINY [CS:APP] Web server, 992, 992–1000

TLB index (TLBI), 853

TLB tags (TLBT), 853, 859

TLBI (TLB index), 853

---

<!-- Page 1103 -->

LBS (translation lookaside buffers), 506, 853, 853–861

TLBT (TLB tags), 853, 859

TMax (maximum two's complement number), 96, 101, 102

TMin (minimum two's complement number), 96, 101, 102, 113

top of stack, 226, 226

rop tool, 822

topological sorts of vertices, 778

Torvalds, Linus, 56

touching pages, 869

TRACE method, 987

tracing execution, 423, 430–431, 439

track density of disks, 627

tracks, disk, 626, 631

trajectories in progress graphs, 1036, 1036

transactions

bus, 623, 624–625

client-server model, 954

client-server vs. database, 955

HTTP, 986–989

transfer time for disks, 630

transfer units, 648

transferring control, 277–281

transformations, reassociation, 577, 577–582, 606

transistors in Moore’s Law, 205

transitions

progress graphs, 1035

state machines, 1016

translating programs, 40–41

translation

address. See address translation

switch statements, 269

translation lookaside buffers (TLBs), 506, 853, 853–861

Transmission Control Protocol (TCP), 960

Transmission Control Protocol/

Internet Protocol (TCP/IP),

960

trap exception class, 763

traps, 763, 763–764

tree height reduction, 606

tree structure, 306–307

truncating numbers, 117–118

two-operand multiply instructions,

234

two-way parallelism, 572–573

wo's-complement representation

addition, 126–131

asymmetric range, 102, 113

bit-level representation, 132

encodings, 68

minimum value, 101

multiplication, 133–137

negation, 131

signed and unsigned conversions,

106–110

signed numbers, 100, 100–106



typedef [C] type definition, 80, 83

types

  conversions. See conversions

  floating point, 160–162

  integral, 96, 96–98

  machine-level, 207, 213–214

  MIME, 985

  naming, 83

  pointers, 72, 313

  pointers associated with, 70

U2B (unsigned to binary conversion), 96, 100, 107, 110

U2T (unsigned to two's-complement conversion), 96, 107, 109, 118

ucomisd [x86-64] compare double precision, 342

ucomiss [x86-64] compare single precision, 342

UDP (Unreliable Datagram Protocol), 960

UINT_MAX constant, maximum

unsigned integer, 104

UINTN_MAX [C] maximum value of N-bit unsigned data type, 103

uintN_t [C] N-bit unsigned integer data type, 103

umask function, 930–931

UMax (maximum unsigned number), 99, 102–103

unallocated pages, 841

unary operations, 230

unblocking signals, 800–801

unbuffered input and output, 933–934

uncached pages, 842

unconditional jump instruction, 393

underflow, gradual, 151

Unicode characters, 86

unified caches, 667

uniform resource identifiers (URIs), 987

uninitialized memory, reading, 907

unions, 80, 305–309

uniprocessor systems, 52, 60

United States, ARPA creation in, 967

universal resource locators (URLs), 985

Universal Serial Bus (USB), 632

Unix 4.xBSD, 52, 968



unix_error [CS:APP] reports Unix-style errors, 774, 774, 1079

Unix IPC, 1013

Unix operating systems, 52, 52, 71

constants, 782

error handling, 1079, 1079

I/O, 55, 926, 926–927

Unix signals, 795

unlocking mutexes, 1039

unmap disk object function, 875

unordered, floating-point comparison outcome, 342

unpack and interleave low packed double precision instruction, 334

unpack and interleave low packed

single precision instruction, 334

Unreliable Datagram Protocol (UDP), 960

unrolling

 $ k \times 1,567 $

 $ k \times 1a,580 $

 $ k \times k,575-576 $

loops, 538, 540, 567, 567–571, 608

unsafe regions in progress graphs,

1036

unsafe trajectories in progress graphs, 1036

unsetenv [Unix] delete environment variable, 788

unsigned [C] integer data type, 77, 97

unsigned representations, 119–120

addition, 120–126

conversions, 106–112

division, 234, 235

encodings, 68, 98–100

integers, 76

maximum value, 99

multiplication, 132–133, 234, 23

unsigned size type, 932

update instructions, 45–46

URIs (uniform resource identifiers), 987

URLs (universal resource locators), 985

USB (Universal Serial Bus), 632

user-level memory mapping, 873–875

user mode, 762

processes, 770–772, 771

regular functions in, 764

user stack, 55

UTF-8 characters, 86

V [CS:APP] wrapper function for Posix sem_post, 1038

---

<!-- Page 1104 -->

v-node tables, 942

V semaphore operation, 1037, 1037–1038

VA. See virtual addresses (VA)

vaddsd [x86-64] double-precision addition, 338

vaddss [x86-64] single-precision addition, 338

VALGRIND program, 605

valid bit

cache lines, 651

page tables, 843

values, pointers, 72, 313

vandpd [x86-64] and packed double precision, 341

vandps [x86-64] and packed single precision, 341

variable-size stack frames, 326–329

variables

mapping, 1030–1031

nonexistent, 910

shared, 1028–1031, 1029

storage classes, 1030–103

VAX computers (Digital Equip Corporation), Boolean operations, 92

vcvtps2pd [x86-64] convert packed single to packed double precision, 334

vcvtsi2sd [x86-64] convert integer to double precision, 333

vcvtsi2sdq [x86-64] convert quad-word integer to double precision, 333

vcvtsi2ss [x86-64] convert integer to single precision, 333

vcvtsi2ssq [x86-64] convert quad-

word integer to single precision,

333

vcvttsd2si [x86-64] convert double precision to integer, 333

vcvttsd2siq [x86-64] convert double precision to quad-word integer, 333

vcvttss2si [x86-64] convert single precision to integer, 333

vcvttss2siq [x86-64] convert single precision to quad-word integer, 333

vdivsd [x86-64] double-precision division, 338

vdivss [x86-64] single-precision division, 338

vector data types, 62, 540–543

vector dot product function, 658

vector registers, 207, 582

vector sum function, 670, 671–672

vectors, bit, 87, 87–88

verification in pipelining, 502

Verilog hardware description language for logic design, 409

Y86-64 pipelining implementation, 503

vertical bars || for or operation, 409

VHDL hardware description

language, 409

victim blocks, 648

Video RAM (VRAM), 622

virtual address spaces, 54, 70, 840

virtual addresses (VA)

machine-level programming, 206–207

vs. physical, 839–840

Y86-64, 392

virtual machines

as abstraction, 63

Java byte code, 346

virtual memory (VM), 51, 54, 70, 838

as abstraction, 63

address spaces, 840–841

address translation. See address translation

bugs, 906–911

for caching, 841–847

characteristics, 838–839

Core i7, 861–864

dynamic memory allocation. See dynamic memory allocation

garbage collection, 901–906

Linux, 866–869

in loading, 735

managing, 875

mapping. See memory mapping

for memory management, 847–848

for memory protection, 848–849

overview, 54–55

physical vs. virtual addresses, 839–840

summary, 911–912

virtual page numbers (VPNs), 850

virtual page offset (VPO), 850

virtual pages (VPs), 325, 841, 841–842

viruses, 321–322

VLOG implementation of Y86-64

pipelining, 503

VM. See virtual memory (VM)

vmaxsd [x86-64] double-precision maximum, 338

vmaxss [x86-64] single-precision maximum, 338



vminsd [x86-64] double-precision minimum, 338

vminss [x86-64] single-precision minimum, 338

vmovapd [x86-64] move aligned, packed double precision, 332

vmovaps [x86-64] move aligned, packed single precision, 332

vmovsd [x86-64] move double precision, 332

vmovss [x86-64] move single precision, 332

vmulsd [x86-64] double-precision multiplication, 338

vmulss [x86-64] single-precision multiplication, 338

void* [C] untyped pointers, 84

volatile [C] volatile type qualifier, 805–806

VP (virtual pages), 325, 841, 841–842

VPNs (virtual page numbers), 850

VPO (virtual page offset), 850

VRAM (video RAM), 622

vsubsd [x86-64] double-precision subtraction, 338

vsubss [x86-64] single-precision subtraction, 338

VTUNE program, 605

vulnerabilities, security, 122–123

vunpcklpd [x86-64] unpack and interleave low packed double precision, 334

vunpcklps [x86-64] unpack and interleave low packed single precision, 334

vxorpd [x86-64] EXCLUSIVE-OR packed double precision, 341

vxorps [x86-64] EXCLUSIVE-OR packed single precision, 341

wait [Unix] wait for child process, 782

wait for child process functions, 780, 782–785

wait for client connection request function, 972, 972–973

wait for signal instruction, 817

wait.h file, 782

wait sets, 780, 780

waiting for signals, 814–817

waitpid [Unix] wait for child process 779, 782–785

waitpid1 [CS:APP] waitpid

example, 783

---

<!-- Page 1105 -->

waitpid2 [CS:APP] waitpid

example, 785

WANs (wide area networks), 957, 957–958

warming up caches, 648

WCONTINUED constant, 780

weak scaling, 1055, 1056

weak symbols, 716

wear leveling logic, 637

Web clients, 984, 984

Web servers, 737, 984

basics, 984–985

dynamic content, 989–990

HTTP transactions, 986–989

Tiny example, 992–1000

Web content, 985–986

well-known ports, 966

well-known service names, 966

while [C] loop statement, 259–264

wide area networks (WANs), 957, 957–958

WIFEXITED constant, 781

WIFEXITSTATUS constant, 781

WIFSIGNALED constant, 781

WIFSTOPPED constant, 781

Windows Microsoft operating system, 63, 81

wire names in hardware diagrams, 434

WNOHANG constant, 780–781

word-level combinational circuits,

412–416

word selection

direct-mapped caches, 655

fully associative caches, 663–664

set associative caches, 661–662

word size, 44, 75

words, 44, 213

working sets, 649, 846

World Wide Web, 985

worm programs, 320–322

wrapper functions, 747

error handling, 774, 1077, 1079–1081

interpositioning libraries, 744

write access, 325

write-allocate approach, 666

write-back approach, 666

write-back stage

instruction processing, 421, 423–433

PIPE processor, 485–489

sequential processing, 436

sequential Y86-64 implementation, 442–444



write [Unix] write file, 931, 932–93.

write hits, 666

write issues for caches, 666–66

write-only register, 563

write operations for files, 927, 932–933

write ports

priorities, 444

register files, 418

write/read dependencies, 593–595

write strategies for caches, 669

write transactions, 623, 624–625

written function, 939

writers in readers-writers problem,

1042, 1044

writing

signal handlers, 802–811

SSD operations, 636

WSTOPSIG constant, 781

WTERMSIG constant, 781

WUNTRACED constant, 780–781

x86-64 instruction set architecture vs.

Y86-64, 396

x86-64 microprocessors, 204

array access, 292

conditional move instructions, 250–256

data alignment, 312

exceptions, 765–767

Intel-compatible 64-bit microprocessors, 81

machine language, 201–202

registers

data movement, 218–225

operand specifiers, 216–218

vs. Y86-64, 401–402

x87 microprocessors, 203

XDR library security vulnerability, 136

%xmm [x86-64] 16-byte media register. Subregion of YMM, 331

%×mm0, return floating-point value register, 335, 337

XMM, SSE vector registers, 330–332



XOR [instruction class] EXCLUSIVE-OR,

228

xorq [Y86-64] EXCLUSIVE-OR, 392

Y86-64 instruction set architecture

389–390

details, 406–408

exception handling, 399–400

hazards, 471

instruction encoding, 394–396

instruction set, 392–394

programmer-visible state, 391–392

programs, 400–406

sequential implementation.

See sequential Y86-64 implementation

vs. x86-64, 396

Y86-64 pipelined implementations, 457

computation stages, 457–458

control logic. See control logic in pipelining

exception handling, 480–483

hazards. See hazards in pipelining

memory system interfacing, 505–506

multicycle instructions, 504–505

performance analysis, 500–504

predicted values, 463–465

register insertions, 458–462

signals, 462–463

stages. See PIPE processor stages testing, 501

verification, 502

Verilog, 503

YAS Y86-64 assembler, 402

YIS Y86-64 instruction set simulator, 402

%ymm [x86-64] 32-byte media register, 331

YMM, AVX vector registers, 330–332

zero extension, 113

zero flag condition code, 237, 342, 391

ZF [x86-64] zero flag condition code, 237, 342, 391

zombie processes, 779, 779–780, 806

zones, recording, 628

---
